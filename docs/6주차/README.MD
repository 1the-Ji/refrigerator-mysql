# 09. 사용자 정의 변수
- 누가 생성 : 사용자 변수 / 시스템 변수
- 변수 적용 범위 : 서버전체 -> 글로벌 변수 / 커넥션 -> 세션 변수
- 동적 변수 변경 가능 : 동적 변수 / 정적 변수
- 시스템 변수 : 고정 이름 사용 / 사용자 정븨 변수 : 임의 이름 부여 가능

## 9.1 사용자 정의 변수 소개 
- 사용자 정의 변수는 스토어드 프로시저, 함수뿐 아니라 SQL 문장에서 사용가능
- 사용자 변수 이름은 "@" 시작
- 별도의 타입을 정의하지 않고 저장하는 값에 의해서 그 타입이 정해짐
- 저장할 수 있는 값은 Integer, Decimal, Float, Binary, 문자열, NULL(초기값을 설정하지 않을때 때도 NULL)
- SET 문장으로 값이 할당됨가 동시에 생성
- 연산 결과를 다시 사용자 변수에 할당하는 것도 가능
- MySQL 버전별로 사용자 변수의 동작 방식 일관성을 보장하지 않으므로 '절대 동일 SQL문장에서 변수에 값을 할당하고 동시에 값을 참조하지 말라' 라고 한다.
- 하지만 동일한 버전에서는 일관된 결과를 보장받을 수 있다.
- 사용자 변수 사용 주의 사항
  - MySQL 5.0 미만의 버전에서는 대소문자 구분
  - 쿼리 캐시 기능 사용 못함
  - 초기화 하지 않으면 문자열 타입의 NULL
  - 사용자 정의 변수 연산 순서는 안정해져있음
  - 여러 버전에서 동일한 연산 일관성을 보장하지 않음

## 9.2 사용자 변수의 기본 활용
- 커넥션 간에는 공유되지 않지만 하나의 커넥션에서는 공유된다.
- 커넥션 풀을 사용하는 어플리케이션에서는 변수를 초기화하지 않는다면 상호 영향을 끼칠 수 있음
- 매번 set을 통해 초기화 하는 작업이 필요함
- 보통 FROM절을 사용한 초기화를 많이 사용함

```sql
SELECT (@rownum:=@rownum+1) AS rownum, emp_no, first_name
  FROM employees, (SELECT @rownum:=0) der_tab
 LIMIT 5;
```

- FROM 절의 (SELECT @rownum:=0)는 SET 명령과 동일한 역할을 수행한다. FORM 절은 쿼리 실행시 한번만 참조되기 때문에 변수 초기화에 좋은 위치이다.
- (SELECT @rownum:=0) 절은 employees와 조건없이 조인되지만 스칼라값만을 출력하는 테이블이어서 성능에 영햐을 끼치지 않는다.
- 다만 JOIN UPDATE, JOIN DELETE 문장에서는 테이블이 2개 이상일때 ORDER BY 절을 사용할 수 없으므로 사용할 수 없다.
- (@rownum:=@rownum+1) 는 성공 여부를 반환하는게 아니라 할당한 값을 반환한다.

## 9.3 사용자 변수의 적용 예제

### 9.3.1 N번째 레코드만 가져오기
- 5.x  버전에서 동작
```sql
select *
  from departments, (select @rn:=0) as x
 where (@rn:=@rn+1) = 3
 order by dept_name
```

### 9.3.2 누적 합계 구하기
- 사용자 정의 변수를 활용해 읽어 오는 레코드 순서대로 누적 합계도 쉽계 처리 가능
```sql
select emp_no, salary, (@acc_salary:=@acc_salary+salary) as acc_salary
  from salaries, (select @acc_salary:=0) x
 limit 10;

```
### 9.3.3 그룹별 랭킹 구하기
```sql
select emp_no, first_name, last_name, if(@prev_firstname=first_name, @rank:=@rank+1, @rank:=1 + LEAST(0, @prev_firstname:=first_name)) rnak
  from employees, (select @rank:=0) x1, (select @prev_firstname:='DUMMY') x2
 where first_name in('Georgi', 'Bezalel')
 order by first_name, last_name;
```
- 위와 같은 쿼리를 직접 select 해서 결과를 확인해 보면 더 쉽게 이해할 수 있다.

### 9.3.4 랭킹 업데이트 하기
- 사용자 정의 변수는 UPDATE 문에서도 사용할 수 있다.
- 위에서 이야기 했던것과 같이 update문장안에 (select @변수) 를 사용한다면 join update 문장은 order by절을 사용할 수 없으므로 따로 사용자 변수를 초기화 하는 부분이 필요하다.


### 9.3.5 GROUP BY 와 ORDER BY 가 인덱스를 사용하지 못하는 쿼리
- 임시 테이블을 사용할 경우 임시 테이블에 저장된 순서대로 사용자 변수가 연산되어 버리기 때문에 문제가 발생할 수 있음
- 이럴 때는 쿼리 전체를 임시 테이블(파생 테이블)로 만들어 이후 사용자 변수를 사용하는 바업ㅂ이 있음
- 만약 임시 테이블로 만들기 부담이 된다면 인덱스를 사용할 수 있도록 개선이 필요


## 9.4 주의 사항
- 참조와 할당을 같이 사용하고 있기 때문에 안정적인 결과를 버전별로 일관성 있게 보장하지 않음

# 10. 파티션
-  MySQL 입장에서는 데이터를 별도의 테이블로 분리해서 저장하지만 사용자 입장에서는 여전히 하나의 테이블로 읽기와 쓰기를 할 수 있게 해주는 솔루션이다.
-  일반적으로 파티션은 하나의 서버에서 테이블을 분산하는 것
-  기본적으로 해시와 리스트, 그리고 키와 레인지로 4가지 파티션 방법을 제공

## 10.1 개요
### 10.1.1 파티션을 사용하는 이유
- 하나의 테이블이 너무 커서 인덱스의 크기를 물리적인 메모리보다 훨씬 클때
- 데이터 특성상 주기적인 삭제 작업이 필요한 경우

#### 단일 insert와 단일 또는 범위 select의 빠른 처리
- update, delete 처리 대상을 찾기 위해서도 인덱스를 사용
- 만약 한 테이블의 인덱스 크기가 물리적으로 사용가능한 메모리 공간보다 크다면 문제가 발생할 수 있음
- 파티션을 통해 데이터와 인덱스를 조각화 해서 물리적 메모리를 효율적으로 사용 할 수 있게 만들어 준다

#### 데이터의 물리적인 저장소를 분리
- 데이터 / 인덱스 파일이 파일 시스템에서 차지하는 공간이 크다면 백업이나 관리 측면에서 부담이감
- 이러한 문제는 파티션을 통해 파일의 크기를 조절하여 파티션별로 관리가 가능

#### 이력 데이터의 효율적인 관리
- 로그 테이블의 데이터는 일정 기간이 지나면 쓸모가 없어짐
- 또한 단기간 대량 데이터 특성을 가짐
- 파티션 테이블로 관리한다면 불필요한 데이터의 삭제 작업은 파티션 추가나 삭제하는 방법으로 해결 가능

### 10.1.2 MySQL 파티션의 내부 처리

-  예제 테이블
```sql
create table tb_article (
                            article_id int not null,
                            reg_date datetime not null,
                            primary key (article_id, reg_date)
)
    PARTITION BY RANGE (year(reg_date)) (
        PARTITION p2009 VALUES LESS THAN (2010),
        PARTITION p2010 VALUES LESS THAN (2011),
        PARTITION p2011 VALUES LESS THAN (2012),
        PARTITION p9999 VALUES LESS THAN maxvalue
        );

```
#### 파티션 테이블의 레코드 INSERT

- INSERT 되는 칼럼의 값 중에서 파티션 키인  reg_date칼럼의 값을 이용해 파티션 표현시을 평가
- 레코드 파티션이 결정되면 나머지 과정은 파티션되지 않은 일반 테이블과 마찬가지로 처리 된다.
  

#### 파티션 테이블의 UPDATE 
-  변경 대상 레코드가 어느 파티션에 저장돼 있는지 찾아야 한다.
-  WHERE 조건에 파티션 키 컬럼이 조건을 존재하면 그 값을 이용해 레코드가 저장된 파티션에 빠르게 대상 레코드를 검색할 수 있다.
-  조건에 파티션 키 컬럼이 없다면 모든 테이블 파티션 검색을 해야 한다.
-  파티션 키 컬럼이 변경될 때는 기존 레코드가 저장된 파티션에서 해당 레코드를 삭제함
-  이후 파티션 표현식 평가 후 새로운 파티션을 결정해서 레코드를 저장

#### 파티션 테이블의 검색
- 파티션 테이블을 검색할 때 성능에 크게 영향을 미치는 조건
  - WHERE절 조건으로 검색해야 할 파티션을 선택할 수 있는가?
  - WHERE절의 조건이 인덱스를 효율적(인덱스 레인지 스캔)으로 사용할 수 있는가?
- 파티션 선택 가능 + 인덱스 효율적 사용가능
  - 파티션의 개수에 상관없이 꼭 필요한 파티션의 인덱스만 레인지 스캔
- 파티션 선택 불가 + 인덱스 효율적 사용가능
  - 모든 파티션을 대상으로 검색
  - 파티션 개수만큼 인덱스 레인지 스캔을 수행한 다음 결과를 병합
- 파티션 선택 가능 + 인덱스 효율적 사용 불가
  - 대상 파티션 풀 테이블 스캔
- 파티션 선택 불가 + 인덱스 효율적 사용 불가
  - 각 파티션 작업 자체도 풀 테이블 스캔 

#### 파티션 테이블의 인덱스 스캔과 정렬
- 파티션 통합 인덱스 지원 X
- 각 파티션에 대해 인덱스 스캔을 수행할 때, 파티션으로 부터 조건에 일치하는 레코드를 정렬되 ㄴ순서대로 읽음
- 그리고 우선순위 큐에 임시로 저장
- 큐에서 다시 필요한 순서대로 데이터를 가져감


#### 파티션 프루닝
- 파티션 가운데 전부가 아닌 몇개만 읽어도 된다고 판단되면 불필요한 파티션에 접근하지 않는다.

## 10.2 주의사항

### 10.2.1 파티션의 제한 사항
- 숫자 값만 파티션 가능 (5.5 이상부터는 문자열도 가능)
- 키 파티션은 해시 함수를 직접 선택하기 때문에 컬럼 타입 제한 없음
- 최대 1024개 파티션 가능
- 스토어드 루틴이나 UDF 그리고 사용자 변수 등을 파티션 함수나 식에 사용 불가능
- 파티션 생성 이후 서버의 sql_mode 파라미터 변경은 추천하지 않음
- 파티션 테이블에서는 외래키 사용 불가
- 파티션 테이블은 전문 검색 인덱스 생성 불가
- 공장 확장 기능에서 제공되는 컬럼 타입은 파티션 테이블에 사용 불가
- 임시 테이블은 파티션 기능 사용 불가
- MyISAM 파티션 테이블의 경우 키 캐시를 사용할 수없음(5.5는 버그 보완)
- 파티션 키 표현식은 컬럼 or 내장함수 (year, to_days, to_seconds)
- 인덱스는 모두 로컬 인덱스
- 파티션 단위로 인덱스 변경 / 추가 불가능


### 10.2.2 파티션 사용시 주의 사항
- 범위를 좁히기 위해 사용하는 파티션에서는 유니크 키에 대한 체크 작업 때문에 제약사항이 많음

#### 파티션과 유니크(프라이머리 키 포함)
- 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 칼럼을 포함해야 한다.
- 각 유니크 키에 대해 값이 주어지면 해당 레코드가 어느 파티션에 저장돼 있는지 계산할 수 있어야 한다는 점을 기억하자.

#### 파티션과 open_files_limit 파라미터
- 파티션이 많아질 경우 open_files_limit 시스템 변수 설정을 통해 오픈할 수있는 적절한 파일 개수를 설정하는 것이 좋다.

#### 파티션 테이블과 잠금
- 쿼리에 필요한 파티션만 선별하는 파티션 프루닝 작업은 쿼리의 최적화 단계에서 수행되므로 어떤 파티션만 사용될지 알아낼 방법이 업삳.
- 파티션 테이블에 쿼리가 실행되면 서버는 테이블의 파티션 개수에 관계없이 모든 파티션을 열고 잠금을 걸게 된다.
- 적정 수준의 파티션이 있는 테이블에서 느려지는 현상이 발생함
- 파티션이 많이 포함된 테이블에서는 LOCK TABLES 명령으로 테이블을 잠그고 INSERT나 UPDATE를 수행하면 조금 더 빠르게 처리할 수있다.

## 10.3 MySQL 파티션 종류
- 레인지 파티션
- 리스트 파티션
- 해시 파티션
- 키 파티션

### 10.3.1 레인지 파티션
- 다음과 같은 성격을 지닌 테이블에서 유리
  - 날짜를 기반으로 데이터가 누적, 년도나 월/일 단위로 분석 및 삭제를 해야할 때
  - 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
  - 파티션 키 위주로 검색이 자주 실행될 때

#### 레인지 파티션 테이블 생성
- PARTITION BY RANGE 키워드로 생성
- 뒤에 컬럼 또는 내장함수를 이용해 파티션 키 명시
- VALUES LESS THAN으로 명시된 값보다 작은 값만 해당 파티션에 저장되도록 설정, 다만 명시된 값은 포함 X
- VALUES LESS THAN maxvalue로 명시되지 않은 레코드 저장 파티션 설정
- VALUES LESS THAN maxvalue가 없다면 파티션을 못찾으면 에러가 발생
- 테이블과 각 파티션은 같은 스토리지 엔진으로 정의한다.

#### 레인지 파티션의 분리와 병합
- **단순 파티션의 추가**
- VALUES LESS THAN maxvalue 가 정의돼 있을 때는 테이블에 새로운 파티션을 추가할 수 없다. 이때는 파티션을 분리하는 방법으로 새로운 파티션을 끼워 넣어야 한다.

- **단순 파티션 삭제**
- ALTER TABLE emplotees DROP PARTITION p0;

- **기존 파티션의 분리**
- REORGANIZE PARTITION 명령어를 사용
```sql
create table tb_article (
                            article_id int not null,
                            reg_userid varchar(10),
                            reg_date datetime not null,
                            primary key (article_id, reg_date)
)
    PARTITION BY RANGE (year(reg_date)) (
        PARTITION p1 VALUES LESS THAN (2010),
        PARTITION p2 VALUES LESS THAN (2011),
        PARTITION p3 VALUES LESS THAN (2012),
        PARTITION p4 VALUES LESS THAN maxvalue
        );

ALTER TABLE tb_article  REORGANIZE PARTITION p4 INTO (
    PARTITION p4 VALUES LESS THAN (2013),
    PARTITION p5 VALUES LESS THAN MAXVALUE
    );

```

- **기존 파티션의 병합**
- 병합하는 작업 또한 REORGANIZE PARTITION 사용
  

#### 레인지 파티션 주의사항
- NULL값은 어떤 값보다 작은 값으로 간주
- 날짜 값으로 파티션을 만들 경우, 다음과 같은 파티션 키를 사용하는 파티셔닝은 피하는 것이 좋다.
  - UNIX_TIMESTAMP()를 이용한 변환 식을 파티션 키로 사용
  - 날짜를 문자열로 포맷팅한 형태('2021-01-01')의 파티션 키
  - YEAR()나 TO_DAYS() 함수 이외의 함수가 사용된 파티션 키

- 아래 두개의 함수 추천
  -  YEAR(), TO_DAYS()

### 10.3.2 리스트 파티션
- 레인지 파티션과 가장 큰 차이는 키 값 하나하나를 리스트로 나열해야 한다.
- 또한 maxvalue 를 정의할 수 없음

#### 리스트 파티션 용도
- 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 때
- 키 값이연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
- 파티션 키 값을 기준으로 레코드의 건수가 균일하고, 검색 조건에 파티션 키가 자주 사용 될 때

#### 리스트 파티션 테이블 생성

```sql
CREATE TABLE product(
    id INT NOT NULL ,
    name VARCHAR(30),
    category_id INT NOT NULL
)
PARTITION BY LIST (category_id) (
    PARTITION pappliance VALUES IN (3),
    PARTITION pcomputer VALUES IN (1, 9),
    PARTITION psports VALUES IN (2, 6, 7),
    PARTITION petc VALUES IN (4, 5, 8, NULL)

    )
```


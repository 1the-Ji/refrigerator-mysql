# 데이터 모델링 
개념 / 논리 / 물리 / DBMS 구축 4단계로 정의된다. 

- 논리 : 데이터베이스 종류와 관련 없이 업무를 분석하고 그에 따른 데이터 집합, 관계를 표현
- 물리 : 논리 모델링 산출물을 시스템으로 표현 

## 논리 모델링 

- 엔티티의 범위 확정
- 필수 속성 정의
- 엔티티의 의미상 식별자를 선정 
- 엔티티의 관계를 간결히 표현 

여기서 간결은 생략이 아닌, 통합을 의미한다. 

### 모델링 용어 

오브젝트는 2개씩 이름을 갖고있다. (논리, 물리)

- Entity / Table : 논리, 물리 관계가 1 : 1 관계가 아닐수 있다. 

- Attribute / Column : 같은 의미

- Relation / Relation : 같은 의미 

- Key group / index : 키 그룹 표현을 잘 사용하지 않고, 논리, 물리 전부 인덱스라고 표현하다.

- 주제 영역 : 엔티티를 업무 분류별로 나눠서 그룹핑하는데 이를 주제 영역이라고 한다. 

### 용어집 

일명 단어 사전... SKIP

### 엔티티 

엔티티는 2개 이상의 속성을 가지고 1개 이상의 레코드를 가지는 것이 일반적이다.

일반적으로 테이블이라는 칭하는 개체가 바로 엔티티이지만, 1:1 관계를 의미하지는 않는다.

ex) dtype을 통한 singletable

- 3개의 영역으로 표현한다. 
    1. 엔티티의 이름
    2. 식별자 속성
    3. 일반 속성 

- 업무의 흐름이나 중요도에 따라 키, 메인, 액션 3가지로 구분된다.
    1. 키 엔터티 : 관리 데이터 중에서 최상위에 존재하는 엔티티로, 메인, 액션을 만들어 내는 부모 역할을 한다. 
    2. 액션 : 키 엔터티간의 관계로 만들어지는 엔티티
    3. 메인 : 고객, 상품이 키 엔티티라면, 해당 엔티티로 만들어지는 구매, 계약 같은 엔티티가 메인 엔티티이다.
    

- 엔티티의 작명 
    - 단수형을 사용한다. 
    - 수식어는 사용하지 않는다.         
    - list, set 같은 복수형 단어는 사용하지 않는다.
    
### 어트리뷰트 

분리될수 없는 최소의 데이터 보관 단위다. (atomic)

또한 가공되지 않는 그대로의 값을 의미하기도 하는데, 상반된 단어로 추출 칼럼이 있다. (계산된 값)

어트리뷰트는 중복을 제거하지만, 추출컬럼은 중복을 만들어낸다. 

- 네이밍 : 한정자 + 값으로 표현한. ex) 주소 -> 오피스 주소, 로그인 -> 최종로그인일시


### 식별자 

기본키, 식별자는 하나의 엔터티에서 개별 레코드를 식별할 수 있는 어트리뷰트의 조합을 의미한다. 

키 엔티티는 하나의 어트리뷰트 / 액션, 메인 엔티티는 2개 이상의 어트리뷰트로 조합된다. 

그렇지 않으면 oid와 같은 인조키를 남용한 것이라고 볼 수 있다. (그래도 oid를 만드는게 안전한 것 같다.. 물론 인덱스 커버링을 사용하진 못하지만..)


### 관계 

부모 엔티티 식별자가 없어도 자식 엔티티의 레코드가 생성될 수 있을 때 비식별, 반대로 식별관계라고 한다. 

- 관계의 기수성 : 부모 엔티티의 레코드 하나에 자식 엔티티가 얼마나 만들어질 수 있는지(발생빈도)를 의미한다. 

- 관리의 형태 
    1. 계층 관계 : 식별 관계가 반복, 부모 식별자를 상속받는다. 자식으로 갈수록 식별자를 구성하는 어트리뷰트의 개수가 늘어난다. 적절한 수준에서 비식별 관계로 전환하면 좋다. 
    2. 순환 관계 : 엔티티가 부모임과 동시에 자식 엔티티가 되는 재귀적인 형태를 의미한다. (ex.상위 부서코드)
    3. M:M 관계 : 1:M이 90%를 차지한다. 조금 변형된 M:M이다. 물리 모델링에서는 M:M 없어 새로운 테이블로 해결한다. 
    4. BOM 관계 : 제조 공정에서 시작된 모델링으로, 부품을 결합해서 다른 부품을 생성.. 반복 하는 방식  Bill Of Material, 절대 안쓸듯.. 제조 공장 가지 않는 이상
    5. 배타 관계 : 하나의 엔티티에 두 개 이상의 관계가 동시에 존재할 수 없는 형태를 베타 관계라고 한다. (Arc 아크라고 표현하기도 한다.)
        -> 구분하기 위해 보통 type이라는 어트리뷰트를 갖는다. 
        
### 엔티티 통합         

설계를 하다보면, 중복된 엔티티인지 확인하기가 어렵다. 

그렇기에 항상 이 부분을 염두하고 진행해야 한다. 일반적으로 모델링이 진행될수록 엔티티의 개수가 줄어든다. 

### 관계의 통합 

부모, 자식 관계가 여러 번 나타날 수도 있기 떄문에 이를 하나의 관계로 통합할 수 있다. 

- 여러 부모 관계를 타입을 정의하고, 부모 식별자를 하나만 사용한다.


### 모델 정규화 

중복된 데이터를 최소하하고 관계를 정의해 데이터의 이상현상을 방지한다. 

- 중복된 데이터를 전부 변경해야하는데, 실수로 빠트리면 이상현상이 발생된다.. 성능도 문제

1. 제1정규화 
    - 모든 속성은 하나의 값을 가져아 한다. (atomic)
    - ex ) 1,2,3,4
2. 제2정규화
    - 식별자 일부에서 종속되는 어트리뷰트는 제거해야 한다. 
    - 엔티티의 식별자를 구성하는 어트리뷰트가 2개일 때, 그외 어트리뷰트가 2개의 식별자에 종속적인지 확인하는 절차 
    - ex) 친구 PK(회원번호, 회원타입) 회원명 -> 회원명이 회원 테이블에 종속적.
3. 제3정규화 
    - 식별자 이외의 속성간에 종속 관계가 존재하면 안되다. 
    - ex) 회원 PK(회원번호), 회원명, 직업코드, 직업명 -> 직업명이 직업코드에 종속적이다. 
    
4. BNCF 
    - 모든 결정자가 후보키 집합에 속한다. (강한 제 3정규형)
    - 기본키가 일반키에 종속적일 경우 문제 발생    
    - ex) A, B, C열 PK(A, B)일 시 B가 C에 종속적인 상황
    - (A, B) / (B, C) 2개로 분리한다.   
  
5. 제4정규화    
    - 하나의 릴레이션에 두 개 이상의 다치 종속이 존재하여 제거하는 것
    - 다치 종속은 하나의 어트리뷰트가 다른 어트리뷰트의 값 하나를 결정하는 것이 아니라, 몇 개의 값 즉 집합을 결정한다. 
    - 사실 1정규화 때문에 복합적인 값(집합)을 셀로 가질 수 없기에 발생된다. 
    - ex) A,B,C열이 있을 때 A-C/ A-B 연관이 있지만, B-C연관이 없을 경우 발생한다.    
    - (A,B) / (A, C) 2개의 테이블로 분리한다.   
     
6. 제5정규화
    - 조인 종속이 존재하면 5정규화 대상이다.
    - 제 5 정규형은 주어진 테이블이 그보다 더 작은 테이블의 join으로 재구성할 수 없을 때, 즉 테이블을 분해하면 원래 가지고 있던 정보가 손실되어서, 더이상 테이블을 분해할 수 없는 경우일 때, 그 테이블을 제 5 정규형이라고 합니다.
    - 조인 종속이 존재하지 않거나, 모든 조인종속 후보키를 통해서 만족될 경우 
    - A,B,C열이 있을때 A-B / A-C / B-C는 연관이 있지만 A-B-C연관이 없지만 ABC가 PK로 사용되는 경우 발생
    - 조인종속성 : 한 릴레이션이 여러 무손실 분해되는 가능성 
    - 무손실 분해 : 하나의 릴레이션을 분해하고 다시 조인연산을 했을 때 데이터 손실이 없는 경우
    - 조인을 통해서 무손실 분해가 해결된다.
    - 제 5 정규형에 속하는 릴레이션은 무손실 분해할 수는 있으나 현실적으로 그렇게 할 필요가 없는 릴레이션 구조를  의미함  ( 수직분할 )    
   
- references 
    - https://mangastorytelling.tistory.com/entry/04-%EC%A0%95%EA%B7%9C%ED%99%94-Normalization-5
   
   
## 물리 모델링

### PK 선택 

논리 모델링에서는 간결하게 엔티티의 레코드를 대표할 수 있는 어트리뷰투의 집함으로 선정했다. 
하지만 논리 모델링의 키가 항상 물리 모델의 PK가 되는 것은 아니다. 

물리에서는 PK의 순서가 중요하다. (카디날리티..)

- 부모, 자식의 상속 관계의 키에서 개수가 많아 지면 적절히 끊어주어야 한다. 

### 데이터 타입 선정 

- 최소 단위의 타입을 부여하여 메모리 공간을 최적화한다. 
- 날짜 데이터는 숫자 or 날짜 등등으로 바뀔수도있다. 타임스탬프로 저장하면 인덱스 효율이 좋다. 
- IP의 경우 16진수로 변환할것인지..
- 데이터의 특성을 고려해서 길이를 최소화하자. (말이 쉽지 어렵다..)
- 캐릭터 셋의 경우, 관리만 잘된다면 여러개를 사용해서 최적화해도 무방하지만 그게 아니면 utf-8...하나만 사용하자.
- 컬럼의 길이, 캐릭터 셋은 디스크의 크기보단 MySQL 연산(정렬, 그룹핑) 과정에서 필요한 메모리를 줄이기 위한.. 메모리가 초과되면 디스크를 사용하기 때문에.. 메모리상에서 varchar 동적 칼럼을 지원하지 못해 char을 사용한다..
- MyISAM의 경우 NULL or 빈 문자열 디스크 차이가 없다. 
- InnoDB의 경우 NULL의 경우 디스크를 사용하지 않는다. 
- NULL 컬럼에 IN (서브쿼리) 형태의 조건을 조심하자. 
- 데이터 모델링 단계에서 컬럼 타입을 선정하지 말고, 도메인을 사용해서 Integer / varchar 의 타입 변환을 매핑하자. (그냥 타입을 통일하는게 좋을 것 같다.)

### 반정규화 

GROUP BY / COUNT(*) 와 같이 많은 레코드를 대상으로 하는 작업을 빠르게 조회하기 위해 미리 건수를 집계해서 별도의 테이블이나 칼럼으로 저장해두는 것을 

반정규화라고 한다. 

반정규화 컬럼, 테이블을 어떻게 관리할 것 이냐..가 문제이다. 

- 칼럼 복사 : 값을 변경하지 않고 그대로 다른 테이블로 복사해 두는 형태이다. 
    - 조인을 줄이기 위한 케이스는 효율적이지 못하지만, index를 태우기 위해서 사용하면 효율적이다. 물론 자주 변경되면... 별로다.

- 정렬 용도 : 말그대로 order by에 사용하기 위한 용도 

- 요약 칼럼 : 계산의 결과로 만들어진 값을 저장하기 위한 용도 (count)     
    - 변경시마다 개수 증가 or 감소
    - 백그라운드 프로세스로 처리, 하지만 잠금 경합은 줄어들지 않는다. 
    - 20~30분 단위로 배치처리, 정확성이 떨어진다.
- 해시 인덱스 : MD5와 같은 해시 함수를 이용해서 해시 값으로 저장한다. 성능이 좋다. 지원하지 않아도 어플리케이션에서 저장하면 그만 아닌가..??
- 반정규테이블 : 통계용으로 많이 사용한다. 
- JSON도 있다.

# 데이터타입 

- 데이터의 성격에 맞는 최적의 타입
- 가변 길이 컬럼은 최적의 길이를 선정
- 조인 조건으로 사용되는 칼럼은 똑같은 데이터 타입을 선정 

## CHAR vs VARCHAR

### 저장공간 

- 고정길이는 실제 입력되는 칼럼 값의 길이에 따라 사용하는 저장 공간의 크기가 변하지 않는다. 
- 가변길이는 최대 길이가 제한되지만 크기에 따라 저장공간이 달라진다. 하지만 varchar의 경우 저장된 값의 유효 크기가 얼마인지를 별도로 저장하기 떄문에 1~2바이트 추가로 공간이 든다. 255이하는 1바이트 256이상은 2바이트 

실제로 문자열의 길이가 가변or정적으로 정하지는 것은 적절하지 않다. 

실제 기준은 
1. 문자열의 길이가 비슷한가? (가변 or 정적아닌에 대해서 적절하지 않다고 해놓고..?)
2. 자주 변경되는가?

한번 저장된 데이터에 대해서 업데이트를 할 때 char는 고정 길이라 해당 공간에 업데이트하면 된다. 

하지만 varchar는 다른 공간으로 옮기는 작업이 필요하다. 

만약 2~3바이트의 차이라도 자주 변경되면 char를 사용하는게 좋다. 

### 비교 방식 

칼럼 값의 뒷쪽에 붙은 공백 문자는 모두 제거하고 비교를 수행한다.

반면 앞쪽 문자는 유효한 문자로 인식한다. Like 검색은 모두 공백을 인식한다.

### 캐릭터 셋

- system > server > database 

- file / client(request) / connection(receive) / results(response)

- 별도의 문자집합 (인트로듀서) 사용하면 변환하지 않는다. _문자셋이름 붙인다. ex) _latin1'Smith'

- client / connection / results 똑같은 캐릭터 셋이라면 생략한다. 

### 콜레이션 

칼럼의 값에 대한 비교, 정렬에 대한 규칙을 의미한다. 

문자열 칼럼은 콜레이션 없이 문자집합만 가질 수는 없다. 명시적으로 지정하지 않으면, 지정된 문자 집합의 기본 콜레이션이 적용된다. 

- 문자열 칼럼에서 문자집합, 콜레이션이 전부 일치해야 인덱스가 효율적으로 사용된다. 



### 이스케이스 

- "ab\"ba" -> ab"ba
- "ab"""ba" -> ab"ba
- 'ab''ba' -> ab'ba
-> 'ab""ba' -> ab""ba 실패
->  "ab''ba" -> ab''ba 실패 




















    
         


        
     
    
    
    
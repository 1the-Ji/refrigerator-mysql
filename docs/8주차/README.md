# 데이터 모델링 
개념 / 논리 / 물리 / DBMS 구축 4단계로 정의된다. 

- 논리 : 데이터베이스 종류와 관련 없이 업무를 분석하고 그에 따른 데이터 집합, 관계를 표현
- 물리 : 논리 모델링 산출물을 시스템으로 표현 

## 논리 모델링 

- 엔티티의 범위 확정
- 필수 속성 정의
- 엔티티의 의미상 식별자를 선정 
- 엔티티의 관계를 간결히 표현 

여기서 간결은 생략이 아닌, 통합을 의미한다. 

### 모델링 용어 

오브젝트는 2개씩 이름을 갖고있다. (논리, 물리)

- Entity / Table : 논리, 물리 관계가 1 : 1 관계가 아닐수 있다. 

- Attribute / Column : 같은 의미

- Relation / Relation : 같은 의미 

- Key group / index : 키 그룹 표현을 잘 사용하지 않고, 논리, 물리 전부 인덱스라고 표현하다.

- 주제 영역 : 엔티티를 업무 분류별로 나눠서 그룹핑하는데 이를 주제 영역이라고 한다. 

### 용어집 

일명 단어 사전... SKIP

### 엔티티 

엔티티는 2개 이상의 속성을 가지고 1개 이상의 레코드를 가지는 것이 일반적이다.

일반적으로 테이블이라는 칭하는 개체가 바로 엔티티이지만, 1:1 관계를 의미하지는 않는다.

ex) dtype을 통한 singletable

- 3개의 영역으로 표현한다. 
    1. 엔티티의 이름
    2. 식별자 속성
    3. 일반 속성 

- 업무의 흐름이나 중요도에 따라 키, 메인, 액션 3가지로 구분된다.
    1. 키 엔터티 : 관리 데이터 중에서 최상위에 존재하는 엔티티로, 메인, 액션을 만들어 내는 부모 역할을 한다. 
    2. 액션 : 키 엔터티간의 관계로 만들어지는 엔티티
    3. 메인 : 고객, 상품이 키 엔티티라면, 해당 엔티티로 만들어지는 구매, 계약 같은 엔티티가 메인 엔티티이다.
    

- 엔티티의 작명 
    - 단수형을 사용한다. 
    - 수식어는 사용하지 않는다.         
    - list, set 같은 복수형 단어는 사용하지 않는다.
    
### 어트리뷰트 

분리될수 없는 최소의 데이터 보관 단위다. (atomic)

또한 가공되지 않는 그대로의 값을 의미하기도 하는데, 상반된 단어로 추출 칼럼이 있다. (계산된 값)

어트리뷰트는 중복을 제거하지만, 추출컬럼은 중복을 만들어낸다. 

- 네이밍 : 한정자 + 값으로 표현한. ex) 주소 -> 오피스 주소, 로그인 -> 최종로그인일시


### 식별자 

기본키, 식별자는 하나의 엔터티에서 개별 레코드를 식별할 수 있는 어트리뷰트의 조합을 의미한다. 

키 엔티티는 하나의 어트리뷰트 / 액션, 메인 엔티티는 2개 이상의 어트리뷰트로 조합된다. 

그렇지 않으면 oid와 같은 인조키를 남용한 것이라고 볼 수 있다. (그래도 oid를 만드는게 안전한 것 같다.. 물론 인덱스 커버링을 사용하진 못하지만..)


### 관계 

부모 엔티티 식별자가 없어도 자식 엔티티의 레코드가 생성될 수 있을 때 비식별, 반대로 식별관계라고 한다. 

- 관계의 기수성 : 부모 엔티티의 레코드 하나에 자식 엔티티가 얼마나 만들어질 수 있는지(발생빈도)를 의미한다. 

- 관리의 형태 
    1. 계층 관계 : 식별 관계가 반복, 부모 식별자를 상속받는다. 자식으로 갈수록 식별자를 구성하는 어트리뷰트의 개수가 늘어난다. 적절한 수준에서 비식별 관계로 전환하면 좋다. 
    2. 순환 관계 : 엔티티가 부모임과 동시에 자식 엔티티가 되는 재귀적인 형태를 의미한다. (ex.상위 부서코드)
    3. M:M 관계 : 1:M이 90%를 차지한다. 조금 변형된 M:M이다. 물리 모델링에서는 M:M 없어 새로운 테이블로 해결한다. 
    4. BOM 관계 : 제조 공정에서 시작된 모델링으로, 부품을 결합해서 다른 부품을 생성.. 반복 하는 방식  Bill Of Material, 절대 안쓸듯.. 제조 공장 가지 않는 이상
    5. 배타 관계 : 하나의 엔티티에 두 개 이상의 관계가 동시에 존재할 수 없는 형태를 베타 관계라고 한다. (Arc 아크라고 표현하기도 한다.)
        -> 구분하기 위해 보통 type이라는 어트리뷰트를 갖는다. 
        
### 엔티티 통합         

설계를 하다보면, 중복된 엔티티인지 확인하기가 어렵다. 

그렇기에 항상 이 부분을 염두하고 진행해야 한다. 일반적으로 모델링이 진행될수록 엔티티의 개수가 줄어든다. 

### 관계의 통합 

부모, 자식 관계가 여러 번 나타날 수도 있기 떄문에 이를 하나의 관계로 통합할 수 있다. 

- 여러 부모 관계를 타입을 정의하고, 부모 식별자를 하나만 사용한다.


### 모델 정규화 

중복된 데이터를 최소하하고 관계를 정의해 데이터의 이상현상을 방지한다. 

- 중복된 데이터를 전부 변경해야하는데, 실수로 빠트리면 이상현상이 발생된다.. 성능도 문제

1. 제1정규화 
    - 모든 속성은 하나의 값을 가져아 한다. (atomic)
    - ex ) 1,2,3,4
2. 제2정규화
    - 식별자 일부에서 종속되는 어트리뷰트는 제거해야 한다. 
    - 엔티티의 식별자를 구성하는 어트리뷰트가 2개일 때, 그외 어트리뷰트가 2개의 식별자에 종속적인지 확인하는 절차 
    - ex) 친구 PK(회원번호, 회원타입) 회원명 -> 회원명이 회원 테이블에 종속적.
3. 제3정규화 
    - 식별자 이외의 속성간에 종속 관계가 존재하면 안되다. 
    - ex) 회원 PK(회원번호), 회원명, 직업코드, 직업명 -> 직업명이 직업코드에 종속적이다. 
    
4. BNCF 
    - 모든 결정자가 후보키 집합에 속한다. (강한 제 3정규형)
    - 기본키가 일반키에 종속적일 경우 문제 발생    
    - ex) A, B, C열 PK(A, B)일 시 B가 C에 종속적인 상황
    - (A, B) / (B, C) 2개로 분리한다.   
  
5. 제4정규화    
    - 하나의 릴레이션에 두 개 이상의 다치 종속이 존재하여 제거하는 것
    - 다치 종속은 하나의 어트리뷰트가 다른 어트리뷰트의 값 하나를 결정하는 것이 아니라, 몇 개의 값 즉 집합을 결정한다. 
    - 사실 1정규화 때문에 복합적인 값(집합)을 셀로 가질 수 없기에 발생된다. 
    - ex) A,B,C열이 있을 때 A-C/ A-B 연관이 있지만, B-C연관이 없을 경우 발생한다.    
    - (A,B) / (A, C) 2개의 테이블로 분리한다.   
     
6. 제5정규화
    - 조인 종속이 존재하면 5정규화 대상이다.
    - 제 5 정규형은 주어진 테이블이 그보다 더 작은 테이블의 join으로 재구성할 수 없을 때, 즉 테이블을 분해하면 원래 가지고 있던 정보가 손실되어서, 더이상 테이블을 분해할 수 없는 경우일 때, 그 테이블을 제 5 정규형이라고 합니다.
    - 조인 종속이 존재하지 않거나, 모든 조인종속 후보키를 통해서 만족될 경우 
    - A,B,C열이 있을때 A-B / A-C / B-C는 연관이 있지만 A-B-C연관이 없지만 ABC가 PK로 사용되는 경우 발생
    - 조인종속성 : 한 릴레이션이 여러 무손실 분해되는 가능성 
    - 무손실 분해 : 하나의 릴레이션을 분해하고 다시 조인연산을 했을 때 데이터 손실이 없는 경우
    - 조인을 통해서 무손실 분해가 해결된다.
    - 제 5 정규형에 속하는 릴레이션은 무손실 분해할 수는 있으나 현실적으로 그렇게 할 필요가 없는 릴레이션 구조를  의미함  ( 수직분할 )    
   
- references 
    - https://mangastorytelling.tistory.com/entry/04-%EC%A0%95%EA%B7%9C%ED%99%94-Normalization-5
   
   
## 물리 모델링

### PK 선택 

논리 모델링에서는 간결하게 엔티티의 레코드를 대표할 수 있는 어트리뷰투의 집함으로 선정했다. 
하지만 논리 모델링의 키가 항상 물리 모델의 PK가 되는 것은 아니다. 

물리에서는 PK의 순서가 중요하다. (카디날리티..)

- 부모, 자식의 상속 관계의 키에서 개수가 많아 지면 적절히 끊어주어야 한다. 

### 데이터 타입 선정 

- 최소 단위의 타입을 부여하여 메모리 공간을 최적화한다. 
- 날짜 데이터는 숫자 or 날짜 등등으로 바뀔수도있다. 타임스탬프로 저장하면 인덱스 효율이 좋다. 
- IP의 경우 16진수로 변환할것인지..
- 데이터의 특성을 고려해서 길이를 최소화하자. (말이 쉽지 어렵다..)
- 캐릭터 셋의 경우, 관리만 잘된다면 여러개를 사용해서 최적화해도 무방하지만 그게 아니면 utf-8...하나만 사용하자.
- 컬럼의 길이, 캐릭터 셋은 디스크의 크기보단 MySQL 연산(정렬, 그룹핑) 과정에서 필요한 메모리를 줄이기 위한.. 메모리가 초과되면 디스크를 사용하기 때문에.. 메모리상에서 varchar 동적 칼럼을 지원하지 못해 char을 사용한다..
- MyISAM의 경우 NULL or 빈 문자열 디스크 차이가 없다. 
- InnoDB의 경우 NULL의 경우 디스크를 사용하지 않는다. 
- NULL 컬럼에 IN (서브쿼리) 형태의 조건을 조심하자. 
- 데이터 모델링 단계에서 컬럼 타입을 선정하지 말고, 도메인을 사용해서 Integer / varchar 의 타입 변환을 매핑하자. (그냥 타입을 통일하는게 좋을 것 같다.)

### 반정규화 

GROUP BY / COUNT(*) 와 같이 많은 레코드를 대상으로 하는 작업을 빠르게 조회하기 위해 미리 건수를 집계해서 별도의 테이블이나 칼럼으로 저장해두는 것을 

반정규화라고 한다. 

반정규화 컬럼, 테이블을 어떻게 관리할 것 이냐..가 문제이다. 

- 칼럼 복사 : 값을 변경하지 않고 그대로 다른 테이블로 복사해 두는 형태이다. 
    - 조인을 줄이기 위한 케이스는 효율적이지 못하지만, index를 태우기 위해서 사용하면 효율적이다. 물론 자주 변경되면... 별로다.

- 정렬 용도 : 말그대로 order by에 사용하기 위한 용도 

- 요약 칼럼 : 계산의 결과로 만들어진 값을 저장하기 위한 용도 (count)     
    - 변경시마다 개수 증가 or 감소
    - 백그라운드 프로세스로 처리, 하지만 잠금 경합은 줄어들지 않는다. 
    - 20~30분 단위로 배치처리, 정확성이 떨어진다.
- 해시 인덱스 : MD5와 같은 해시 함수를 이용해서 해시 값으로 저장한다. 성능이 좋다. 지원하지 않아도 어플리케이션에서 저장하면 그만 아닌가..??
- 반정규테이블 : 통계용으로 많이 사용한다. 
- JSON도 있다.

# 데이터타입 

- 데이터의 성격에 맞는 최적의 타입
- 가변 길이 컬럼은 최적의 길이를 선정
- 조인 조건으로 사용되는 칼럼은 똑같은 데이터 타입을 선정 

## CHAR vs VARCHAR

### 저장공간 

- 고정길이는 실제 입력되는 칼럼 값의 길이에 따라 사용하는 저장 공간의 크기가 변하지 않는다. 
- 가변길이는 최대 길이가 제한되지만 크기에 따라 저장공간이 달라진다. 하지만 varchar의 경우 저장된 값의 유효 크기가 얼마인지를 별도로 저장하기 떄문에 1~2바이트 추가로 공간이 든다. 255이하는 1바이트 256이상은 2바이트 

실제로 문자열의 길이가 가변or정적으로 정하지는 것은 적절하지 않다. 

실제 기준은 
1. 문자열의 길이가 비슷한가? (가변 or 정적아닌에 대해서 적절하지 않다고 해놓고..?)
2. 자주 변경되는가?

한번 저장된 데이터에 대해서 업데이트를 할 때 char는 고정 길이라 해당 공간에 업데이트하면 된다. 

하지만 varchar는 다른 공간으로 옮기는 작업이 필요하다. 

만약 2~3바이트의 차이라도 자주 변경되면 char를 사용하는게 좋다. 

### 비교 방식 

칼럼 값의 뒷쪽에 붙은 공백 문자는 모두 제거하고 비교를 수행한다.

반면 앞쪽 문자는 유효한 문자로 인식한다. Like 검색은 모두 공백을 인식한다.

### 캐릭터 셋

- system > server > database 

- file / client(request) / connection(receive) / results(response)

- 별도의 문자집합 (인트로듀서) 사용하면 변환하지 않는다. _문자셋이름 붙인다. ex) _latin1'Smith'

- client / connection / results 똑같은 캐릭터 셋이라면 생략한다. 

### 콜레이션 

칼럼의 값에 대한 비교, 정렬에 대한 규칙을 의미한다. 

문자열 칼럼은 콜레이션 없이 문자집합만 가질 수는 없다. 명시적으로 지정하지 않으면, 지정된 문자 집합의 기본 콜레이션이 적용된다. 

- 문자열 칼럼에서 문자집합, 콜레이션이 전부 일치해야 인덱스가 효율적으로 사용된다. 



### 이스케이스 

- "ab\"ba" -> ab"ba
- "ab"""ba" -> ab"ba
- 'ab''ba' -> ab'ba
-> 'ab""ba' -> ab""ba 실패
->  "ab''ba" -> ab''ba 실패 

## 숫자 

정확도에 따라서 참값, 근사값으로 나눈다. 

- 참값 : 소수점 이하 값의 유무에 관계없이 정확히 그 값을 그대로 유지하는 것을 의미한다. int

- 근사값 : 부동 소수점으로 저장된 값과 조회된 값이 정확하게 일치하지 않고 최대한 비슷한 값을 관리한다.  FLOAT, DOUBLE

저장되는 포맷에 따라 십진, 이진 나눌 수 있다. 

- Integer / BIGINT 전부 이진 표기법으로 저장된다. 

- DECIMAL 65자리까지 저장이 가능하다. 십진법

근사값의 경우 마스터-슬레이브 간에 차이가 발생할수 있어서 float / double은 잘 사용하지 않는다. 

### 정수 

데이터의 타입은 5가지가 있지만, 범위만 다를분 차이가 없다. 

- unsinged 옵션을 정의하면 저장할 수 있는 최대 값보다 2배 커진다. 인덱스의 영향은 없지만 범위가 다르기 때문에 일치시켜야 한다.

### 보둥소수점 

마스터-슬레이브간의 불일치가 발생하기 때문에 자리수만큼 10을 곱해서 정수로 만들자.

### DECIMAL

금액이나 대출 이자 등과 같은 고정된 소수점가지 정확하게 관리해야 할때 사용한다. 

- 비슷한 NUMERIC 도 존재한다.

- 자리수/2 결과값을 올림 처리한 만큼 바이트 수가 필요하다. 

- 정수를 관리하기 위해선 bigint가 더 효율적이다. 


### 정수 주의사항 

- DECIMAL, 부동소수점의 경우 정밀도를 표시한다. 
    -  FLOAT의 경우 정밀도를 조절한다고해도 저장 공간의 크기가 바뀌지 않지만, DECIMAL의 경우 가변형이며 자리수의 결정과 저장 공간의 크기도 제한한다. 
- BIGINT 뒤에 오는 숫자는 크기를 명시하는 부분이 아니다. zeofill와 같이 사용될 때 사용되는 값이다. (처음 알았네..)

### 자동 증가 

- 자동 증가 크기를 조절할 수 있다.

- 자동증가 컬럼와 여러개의 컬럼으로 PK를 생성한다면, 자동증가 컬럼이 가장 앞에 와야한다. 

- 자동증가 컬럼은 테이블당 하나만 사용된다. 

## 날짜와 시간 

- DATTIME은 DBMS의 타임존과 관련없이 클라이언트로부터 입력된 값을 그대로 저장하고 조회할 때도 변환 없이 그대로 노출한다. 
- TIMESTAMP는 항상 UTC로 저장된다. 이후 커넥션 타임존에 따라서 보정 작업이 일어난다. 

글로벌 서비스를 할떄 TIMESTAMP를 사용하면 커넥션에 따라서 알아서 보정처리가 일어난다. 

반면 DATTIME의 경우 타임존 처리를 하지 않기 때문에 잘못된 정보를 볼 수도 있다. 

### TIMESTAMP

TIMESTAMP 칼럼 값은 레코드가 UPDATE / INSET 될 때 자동으로 현재시간으로 변경된다. 

만댝 2개 이상의 TIMESTAMP가 존재하고 아무런 설정을 하지 않는다면, 첫번쨰로 명시한 TIMESTAMP만 동작한다. 

## ENUM / SET 


### ENUM

코드화된 값을 관리한느 용도이다. 

enum 연산을 할 경우 내부적으로 지정된 숫자 값으로 수행된다. 

- 문자열의 종류가 255개 미만이면 저장공간을 1바이트로 저장한다. 그 이상인 경우 2바이트로 저장한다. 

- 순서대로 1부터 할당된다. 빈문자열의 경우 0으로 매핑된다. 

- 새로운 값이 추가/제거 되면 테이블 구조를 변경해야 한다. 레코드 건수가 많으면 서비스를 멈추고 변경해야 할지도 모른다. 

- 5.1 부터는 마지막에 추가되면 테이블 데이터는 변경하지 않고 추가가능하다. 

### SET 

문자열 값을 정수 값으로 매핑해서 저장하는 방식은 똑같다. 

SET 은 ENUM과 달리 1개 이상의 값을 저장할 수 있다. 

- find_in_set 함수를 통해 검색이 가능하다. (인덱스 사용 불가능)

## TEXT, BLOB

대량의 데이터를 저장하는 방식, 보통 JSON 저장한다. 

둘의 차이점은 TEXT은 문자열을 저장하는 컬럼이라 문자집합, 콜레이션을 가진다는 것이고 

BLOB 타입은 이진 데이터 타입이라 별도의 문자집합, 콜레이션을 가지지 않는다. 

- 임시 테이블은 메모리에 저장이 불가능하기 때문에 SELECT *.. 보단 필요한 컬람만 사용하자. 

## 공간 데이터 타입 
GPS를 이용한 위치 정보를 포함해 모든 좌표 형식의 데이터를 관리할 수 있는 개념이다. 

### POINT
x, y 좌표로만 구성된 데이터를 저장한다. 

- 이진 값으로 저장하기 때문에 AsText() 함수를 이용해 포맷을 변환해서 봐야한다. 

### LINESTRING

직선뿐만 아니라 여러 개의 꺾임이 있는 연결된 선도 모두 저장할수 있다. 

### POLYGON 

POLYGON 타입은 다각형을 저장할 수 있는 데이터 타입 

### GEOMETRY 

모든 위치 타입을 저장할 수 있는 슈퍼타입












    


















    
         


        
     
    
    
    
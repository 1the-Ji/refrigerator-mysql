

## 1주차 아키텍처

## 1.1 MySQL 전체구조

MySQL는 크게 응용프로그램 / MySQL 서버 / 운영체제 & 하드웨어 나뉘고

MySQL 서버는 크게 MySQL 엔진 / 스토리지 엔진으로 구분해서 볼 수 있다. 



### MySQL 엔진

- 클라이언트로부터 접속 및 쿼리 요청을 처리하는 커넥션 핸들러
- SQL 파서 및 전처리기
- 옵티마이저

3가지가 중심을 이룬다. 또한 성능 향상을 위해 MyISAM의 키 캐시, InnoDB의 버퍼 풀, 보조 저장소 기능이 포함되어있다.



### 스토리지 엔진

MySQL엔진은 요청된 SQL 문장을 분석하거나 최적화하고

실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담한다. 



MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러개를 사용할 수 있다. 



### 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터 쓰거나 읽어야 할 때는 스토리지 엔진에게 요청을 "핸들러 요청"이라고 한다. 

핸들러 API를 이용해 MySQL 엔진과 데이터를 주고 받는다. 

~~~sql
show global status like 'Handler%'
~~~

: show status - MySQL 데이타베이스의 현재 상황을 확인한다. 

global : 시스템 전역 변수값 반대로 SESSION이 존재하고 현재 연결에 유요한 값을 표시한다.

![MySQL](../img/show.png)

- referencs : https://dev.mysql.com/doc/refman/8.0/en/server-status-variables.html

 - Handler_read_first : Index의 첫번째 Node Access, FULL_INDEX_SCAN
 - Handler_read_key : 특정값으로 Tree Search를 통해 index Node를 선택하는 경우, INDEX_SEEK
 - Handler_read_next : 인덱스의 leaf노드들의 링크를 Range스캔할 경우
 - Handler_read_prev : 위와 반대로 역순 Range스캔
 - Handler_read_random : Sorting같은 Buffer에 저장된 row에 대한 Access
 - Handler_read_random_next : 데이터Block나 Temp Table에서 순차적으로 row를 읽는 경우,FULL_TABLE_SCAN

: 추후 index에서... 



## 1.2 스레딩 

프로세스 기반이 아닌, 스레드 기반으로 

포그라운드 / 백그라운드 두가지로 구분된다.

SQL 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만, 읽기 작업은 절대로 지연될 수 없다.

일반적으로 DBMS는 쓰기 작업은 버퍼링을 통한 일괄처리 기능이 탐재되어 있다. (InnoDB)

MyISAM의 경우는 사용자가 스레드가 직접 쓰기 작업까지 처리한다.

이러한 이유로 InnoDB에서는 insert / update / delete 디스크에 저장될떄가지 기다리지 않아도 되지만 

MyISAM의 경우 버퍼링 기능을 사용할 수 없다.

### 포그라운드(클라이언트) = 사용자 스레드

MySQL 서버에 접속된 클라이언트의 수만큼 존재하며 주로 클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 것이 임무다.

클라이언트가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드풀로 돌아간다.

만약 thread_cache_size보다 많으면 스레드풀로 돌아가지 않는다.

MySQL의 데이터 버퍼나 캐시로부터 데이터를 가져오고, 버퍼나 캐시에 없는 경우 직접 인덱스 파일로부터 데이터를 읽어와서 처리한다.

MyISAM 테이블 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만, InnoDB의 경우 디스크 기은 백그라운드 스레드가 처리한다.

### 백그라운드

마이아이삼의 경우에는 해당 사항이 별로 없다.

이노디비의 경우 인서트 버퍼, 로그 기록, 데이터 버퍼에서 디스크로 기록, 디스크에서 버퍼로 읽어들이는, 데드락 모니터링 등 여러가지 업무를 처리한다.


- 로그 스레드 : 로그를 디스크로 기록하는 작업
- 쓰기 스레드 : 버퍼의 데이터를 디스크로 내려 쓰는 작업, 해당 스레드 개수를 지정할 수 있다. (innodb_write_io_threads)


## 1.3 메모리 

크게 글로벌 / 로컬 두가지 영역으로 구분된다.

- 글로벌 : MySQL 서버가 시작되면서 운영체제로부터 할당된다 .

MySQL 수많은 스레드가 공유하는 자원이 글로벌, 아니면 로컬


- 로컬 : 세션 메모리 영역이라고 표현하며 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다. 

커넥션이 열려 있는 동안 남아있는 공간 (버퍼)과 쿼리 실행하는 순간에만 할당했다가 사라지는 공간(소트버퍼, 조인버퍼)도 있다.


## 1.4 플러그인 스토리지 엔진 모델 

MySQL의 독특한 구조?로 플러그인 모델이 있다. 

전문 검색 엔진을 위한 파서(인덱싱할 키워드를 분리)도 플러그인 형태로 개발해서 사용할 수 있다. 

### 쿼리 실행 과정 

- SQL 파서 -> SQL 옵티마이저 -> SQL 실행기 -> 데이터 읽기/ 쓰기 -> 디스크 
(MySQL 엔진의 처리 영역) ------------------/(스토리지 엔진의 처리 영역) / 디스크 

데이터 읽기 / 쓰기 작업은 거의 대부분 1건의 레코드 단위로 처리된다. 

핸들러라는 표현을 자주 볼 수 있을텐데, 이는 소스코드로부터 넘어온 표현이다. 

Group By , Order By 와 같은 복잡한? 쿼리는 스토리지 엔진 영역이 아니라 MySQL 처리 영역인 쿼리 실행기에서 처리된다. 


스토리지 엔진에 따라서 데이터 읽기 / 쓰기 많이 달라진다는 소리이다. 


### show engines 

~~~sql
show engines 
~~~
- YES : 서버에 포함돼 있고, 사용 가능 
- DEFAULT : 필수 엔진, 없으면 MySQL이 시작될 수 없음 
- NO : 포함되지 않음 
- DISABLED : 포함됐지만, 파라미터에 의해 비활성화

### show plugins 

엔진 뿐만 아니라, 플러그인 살펴 볼 수 있다.
~~~sql
show plugins 
~~~

## 1.5 쿼리 실행 구조 

0. 쿼리 요청 
1. 쿼리 컴파일러 
   - 2.1 쿼리 파서 
   - 2.2 전처리기 
   - 2.3 옵티마이저 (쿼리 변환, 비용 최적화, 실행계획 개선)
2. 쿼리 실행기 
3. 스토리지 엔진 
4. 하드웨어 
5. 스토리지 엔진
6. 쿼리실행기
7. 응답 
  
### 파서 

쿼리 문장을 토큰으로 분리하는 작업으로 트리 형태의 구조로 만들어 내는 작업이다. 문법 요류가 이 과정에서 발견된다.

토큰 : MySQL이 인식할수 있는 최소 단위
    
### 전처리기 

파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다. 

테이블 이름, 컬럼 이름, 권한과 같은 체크이다. 

### 옵티마이저 

최적화 쿼리를 담당한다. 

### 실행 엔진 

옵티마이저가 두뇌라면, 실행헨진은 손과 발로 비유 할 수 있다. 

실행엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.

= 파이프라인?
    
### 핸들러 (스토리지 엔진)
MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.

핸들러는 결국 스토리지 엔진을 의미하며, MyISAM 테이블을 조작하는 경우에는 핸들러가 MyISAM 스토리지 엔진이 되고, InnoDB 테이블을 조작하는 경우

핸들러가 InnoDB 스토리지 엔진이 된다. 

## 1.6 복제 

복제는 리플리케이션이라고 하는데, 복제는 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술이다. 

마스터-슬레이브 구조를 사용한다.

### 마스터 

MySQL의 바이너리 로그가 활성화되면 어떤 MySQL 서버든 마스터가 될 수 있다.

애플리케이션 입장에서 본다면 마스터 장비는 주로 데이터가 생성 및 변경 삭제되는 주체라고 볼 수 있다.

데이터 구조 변경 쿼리는 바이너리 로그에 기록하고, 슬레이브 서버에서 바이너리 로그를 읽는다.

Binlog dump 스레드가 해당 업무를 담당하는 스레드이다. 

### 슬레이브 

슬레이브 서버는 릴레이 로그를 가지고 있다. 

마스터로부터 변경 내역을 요청하고 받아온 변경 내역을 릴레이 로그에 기록한다. 

릴레이 로그에 기록된 변경 내역을 재실행하여 마스터와 동일한 상태로 유지한다. 


- 슬레이브는 하나의 마스터만 설정 가능

- 마스터/슬레이브 동기화를 위해 슬레이브는 읽기 전용으로 설정

- 슬레이브 서버는 마스터와 동일한 사양이 적합 
: 수많은 데이터 변경 쿼리가, 슬레이브에서는 하나의 스레드로 모두 처리돼야 한다. 
변경이 잦은 서버일수록 슬레이브 서버의 사양이 더 좋아야 한다. 대게 변경은 조회의 1/10이라 동일한 사양으로..

- 복제가 불필요할 경우 바이너리 로그 중지 
: 바이너리 로그를 생성하기 위해 많은 자원을 소모한다.

로그를 안정적으로 기혹하기 위해 Gap lock, 트랜잭션 커밋마다 쿼리 문장을 바이너리 로그에 기록해야 한다.

AutoCommit이 활성화되면 더욱 심각한 부하로 나타나는데, MyISAM의 경우 AutoCommit라 더욱 많은 자원을 소모한다.

- 바이너리 로그와 트랜잭션 격리 수준 

: 바이너리 기록 방식에 따라서 statement 포맷 방식과 row 포맷 방식이 있다. 

statement의 경우 마스터에서 실행되는 쿼리 문장을 기록하는 방식이며, row 포맷은 마스터에서 실행된 쿼리에 의해 변경된 레코드의 값을 기록하는 방식이다.

statement는 아무리 데이터를 많이 변경하더라도 sql 문장으로 전달히개 때문에 트래픽이 적지만, 정상 복제를 위해서 repeatable-read 사용한다.

반면 row 기반은 트래픽이 많이 발생히지만 read-commit 사용 가능하다.


## 1.7 쿼리 캐시

쿼리 캐시는 단어의 의미와는 달리 SQL 문장을 캐시하는 것이 아니라 **쿼리의 결과**를 메모리에 캐시해 두는 기능이다. 

### 처리 절차 
1. 요청된 쿼리 문장이 캐시에 존재하는가?
    - 공백이나 탭과 같은 문자까지 모두 포함되며, 대소문자까지 완전히 동일해야 같은 쿼리로 인식된다.
2. 결과를 볼 수 있는 권한이 있는가??
3. 트랜잭션 내에서 실행된 쿼리인 경우, 그 결과가 가시 범위 내의 트랜잭션에서 만들어진 결과인가?? (InnoDB)
    - 트랜잭션은 순차적으로 증가하는 6바이트 숫자값으로 ID 를 갖는다. 자신의 ID보다 ID 값이 큰 크랜잭션에서 변경한 작업내역이나 쿼리 결과는 참조할 수 없다.
4. 쿼리에 사용된 기능이 캐시돼도 동일한 결과를 보장할 수 있는가??
    - SYSDATE, RAND 등과 같은 호출 시점에 달라지는 값
    - 프리페어 스테이트먼트의 경우 변수가 결과가 영향을 주는가?
5. 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?
6. 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않을까?
7. 그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 사용됐는가?
    - 임시 테이블, 사용자 변수, SELECT Lock 등의 요소들
    

### 쿼리 캐시 히트율 

~~~sql
show global status
~~~    

캐시 히트율 : Ocache_hits / (Ocache_hits  + Com_select) * 100

Ocache_hits : 캐시 처리로 처리된 수
Com_select : 캐시에서 쿼리를 찾지못해 쿼리를 실행한 수

## 1.8 InnoDB 엔진의 특성 

### 프라이머리 키에 의한 클러스터링 
모든 테이블은 프라이머리키 를 기준으로 클러스터링 되어 저장된다. 즉 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며 
나중에..자세히

### 잠금 없는 읽기 

MVCC(Multi Version Concurrency Control) 기술을 이용해 락을 걸지 않고 읽기 작업을 수행한다. 이것도 나중에..

### 외래 키 지원

마이아이삼에서는 사용 불가능하다.  하지만 이로인해 데드락 발생할 때가 많다. 

### 자동 데드락 감지

데드락 체크 방식으로 변경사항이 적은 트랜잭션을 롤백시킨다. 

### 자동화 복구 

손실이나, 장애가 발생했을 때, 완료하지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지에 대한 복구작업을 한다. 추후에..

### 오라클 아키텍처

MVCC / Undo 오라클과 비슷하다.

## 1.9 InnoDb 버퍼 풀

가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다. 

쓰기 작업을 지연시켜서 일괄 작업으로 처리할 수 있게 해주는 버퍼역할도 한다.


마이아이삼 키 캐시가 인덱스의 캐시만을 주로 처리하는데 비해 InnoDB 버퍼 풀은 데이터와 인덱스 모두 캐시하고 

쓰기 버퍼링의 역할까지 모두 처리한다. 

디스크에 기록되지 않은 데이터를 가지고 있다. (더티 페이지)


주기적 or 특정 조건에 따라 체크 포인트 이벤트가 발생하고 이때 Write 스레드가 필요한 만큼의 페이지만 디스크에 기록한다. 

## 1.10 언두 로그 

업데이트, 델리트와 같이 데이터가 변경될때, 변경하기 전에 보관하는 곳이다. 

(트랜잭션을 커밋하지 않더라도 내용을 undo에 기록한다. )

롤백용도와 격리수준 & 동시성을 제공하는데 사용된다. 

## 1.11 인서트 버퍼 


인서트, 업데이트는 데이터 파일을 변경하는 작업 뿐만 아니라, 해당 테이블에 포함된 인덱스를 업데이트 하는 작업도 필요하다.

인덱스 작업은 상당히 많은 자원을 소모하므로, 변경해야할 인ㄷ게스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행한다.

그렇지 않고 디스크로부터 읽어와서 업데이트해야 한다면 즉시 실행하지 않고 임시 공간에 저장해두고 바로 사용자에게 결과를 반환한다.

이떄 사용하는 메모리 공간을 인서트 버퍼라고 한다.


## 1.12 리두 로그 및 로그 버퍼 

앞서 버퍼 풀과 같은 장치로 성능 향상을 하지만, 이 장치만으로는 ACID를 보장 할 수 없다.

변경된 내용을 순차적으로 디스크에 기록하는 로그 파일을 가지고 있다. 

커밋한 트랜잭션의 수정은 어떤 경우에도 유지(durability)되어야 한다. 이는 커밋한 트랜잭션의 수정을 재반영하는 작업을 REDO라고 한다. 


### Undo / Redo

REDO 는 UNDO를 포함 합니다.
REDO 는 시스템 장애시 복구를 위해 사용 합니다.
복구시에 UNDO 데이터도 같이 복구하구요. Commit 되지 않은 데이터를 Rollback 하게 됩니다.
UNDO 는 Rollback 시에도 사용 되지만 Read Consistency(읽기 일관성) 을 위해서 도 사용 됩니다.
REDO 는 모든 변경사항(UNDO 포함)을 기록 합니다.
복구는 UNDO 를 통해서 복구를 하게 됩니다. 즉, ROLLBACK을 한다는 말이죠.
시스템 장애가 발생하게 되면 UNDO 데이터도 모두 날아가게 되겠죠.
결국 시스템 장애시 REDO 데이터를 이용해서 마지막 CHECK POINT 부터 장애까지의 DB BUFFER CACHE 를 복구하게 됩니다.
이게 완료가 되면 UNDO DATA 를 이용하여 COMMIT 되지 않은 데이터를 모두 ROLLBACK 함으로써 복구를 완료하게 됩니다.
결국 REDO 가 UNDO 를 복구하고 최종적으로 UNDO가 복구를 하게 됩니다.
UNDO(안한것 처럼)는 되돌리는 것 이라고 보시면 될거에요.
어떤 세션에서 DML을 발생시키면 commit이나 rollback을 날리기 전까지 이전 정보를 저장하기 위해서
UNDO 블럭에 해당 정보를 기록하죠.. 해당 세션이 트렌젝션 중에 비정상적으로 종료가 되었다면,
안한것 처럼(UNDO) 다시 원복해야 되니까요.
REDO(다시 함)는 위에 설명에도 있듯이 인스턴스 실패시(DB가 내려감) 데이터 파일에 쓰여지지 않은 커밋된 데이터를 복구한다고 되어 있습니다.
좀 더 설명을 해드리자면 커밋을 날릴 경우 LGWR가 로그 파일에 변경된 정보를 기록하게 되고
그 다음에 DBWR이 버퍼캐쉬에 있는 변경 사항에 대해서 데이터 파일에 내려 쓰게 됩니다.
이는 복구 정보가 더 중요해서 그런 것이라고 이해하시면 됩니다(복구 정보가 있으면 재적용이나 되돌릴 수 있으므로).
DB가 비정상적으로 내려가면, 데이터 파일에 쓰여지지 않은 정보들이 리두로그에 기록되어 있으므로
리두로그에서 정보를 가져와 다시 적용(REDO)하는 것입니다.

- REDO 복구 단계로 복구를 시작해야 하는 시점부터 장애 발생 직전 시점까지 REDO가 필요한 모든 로그를 REDO 복구를 하는 단계이다. 

모든 트랜잭션에 대해서 REDO 복구만 한다는 점이 중요한데, 이러한 REDO 복구가 완료된 시점의 데이터베이스 상태는 장애 발생 시점의 상태와 같게 된다.

- UNDO 복구 단계로 로그를 최신 시점부터 다시 역방향으로 탐색하면서 UNDO 복구가 필요한 로그들에 대해서 UNDO 복구를 수행한다. 

여기서 수행하는 UNDO는 결국 위에서 설명한 트랜잭션 철회 시에 수행하는 UNDO와 같은 방식으로,  

데이터베이스 상태를 장애 시점까지 복원해두고 UNDO 복구를 여러 트랜잭션의 철회로 간단하게 해결할 수 있다.


## 1.13 MVCC

잠금을 사용하지 않고 일관된 읽기를 제공하는 기능으로 undo를 통해 구현한다. 

쿼리의 커밋 여부와 상관없이 버퍼풀은 업데이트된다. (디스크 데이터 파일도 동일하다고 볼 수 있다. Write 스레드에 의해..)

격리수준에 따라 다르겠지만, READ_UNCOMMITTED 라면 버퍼풀 or 디스크에서 읽어가고 

READ_COMMITTED 이상이면 언두 영역에서 읽어온다. 

## 1.14 non-locking consistent read

serializable 아니 경우 select 작업에 대해서 잠금 없이 바로 실행한다.

다른 변경 트랜잭션이 방해하지않고, 변경되기 전의 데이터를 읽기 위해서 언두를 사용한다.

## 1.15 마이아이삼 vs 이노디비
그냥 이노디비 쓰자...

그나마 장점인 전문 검색 기능도... 스핑크스?? 트리튼?? 서드 파티를 쓰는 것이 낫다고 한다.

## 1.16 이노디비와 메모리 스토리지

메모리 스토리지 엔진은 데이터와 인덱스를 모두 메모리에 저장하기 떄문에 매우 빠르다. 

하지만 레코드 수준이 아니라 테이블 수준의 잠금을 이용한다. 그렇기에 동시적인 트래픽이 몰리면

낮은 성능을 보여준다.

 
## 1.17 MyISAM 키 캐시

InnoDB 버퍼풀과 비슷한 역할이다. 인덱스만 대상인데, 또한 인덱스의 디스크 쓰기 작업에 대한 부분적으로 버퍼링 역할을 한다. 

## 1.18 운영체제의 캐시 및 버퍼 
인덱스는 키 캐시를 통해 디스크를 검색하지 않고도 충분히 빠른 검색이 가능하다. 
하지만 데이터는 디스크로부터 I/O 해결해줄 만한 어떠한 캐시나 버퍼링 기능이 없다. 


그래서 운영체제의 캐시 및 버퍼를 사용한다. (InnoDB의 버퍼에는 ... 엄청 구리지만 없는것보단.. 나으니깐)

## 1.19 MEMORY 스토리지 

데이터를 메모리에 저장한다. 

테이블의 최대 크기가 적다. 고정 길이 컬럼 지원, BLOB / LOB 사용 불가능 / 해시 인덱스 사용 

레디스 하위호환...?? 

추후에 배울 임시 테이블용도로 사용한다는...


## 1.20 NDB 클러스터 스토리지 엔진 

Network Database, 네트워크를 통해 데이터 분산을 지원하는 스토리지 엔진이다. 

데이터 분산이나 그로 인한 성능 향상보다는 가용성에 집중된 스토리지 엔진이다. 

관리 노드, 데이터 노드, SQL 노드(or API노드)로 구성된다. 

기본적으로 메모리기반이다. (디스크도 지원이 가능하다.)

빠른 동기화를 위해 메모리를 사용한다. Redis가 있는데... 굳이...

### SPoF (Single Point of Failure)

시스템 구성 요소 중에서, 동작하지 않으면 전체 시스템이 중단되는 요소를 말한다.

### NoSQL
 
NoSQL에서는 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있습니다. 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있습니다.

또한 테이블 간의 관계를 정의하지 않기에, 데이터 분산이 용이하며 성능 향상을 위한 Saclue-up 뿐만이 아닌 Scale-out 또한 가능합니다.

- 스키마(schema) : 필드는 데이터 유형뿐만 아니라 제약사항도 지정할 수 있는데 이러한 제약사항을 스키마라고 부른다
- schema-less : key만 똑같다면 각각의 row들이 다른 컬럼을 갖는 구조 


### 관리노드 

정상상태에서 사용되는 일이 없고, 장애 상황, 처음 시작, 노드 추가,삭제 등에 사용된다. 

### 데이터노드 

데이터 조작 요청을 모두 처리하는 노드이다.

### SQL 노드 (SQL , API)
MySQL 서버를 통해 SQL노드 방식 or 자바 API 사용하는 방식 2가지가 있다. 






## References

- https://d2.naver.com/helloworld/407507
- https://pat98.tistory.com/565








    
    



    

















# 1주차 3. 아키텍처

## 1.1 MySQL 전체구조

MySQL는 크게 응용프로그램 / MySQL 서버 / 운영체제 & 하드웨어 나뉘고

MySQL 서버는 크게 MySQL 엔진 / 스토리지 엔진으로 구분해서 볼 수 있다. 



### MySQL 엔진

- 클라이언트로부터 접속 및 쿼리 요청을 처리하는 커넥션 핸들러
- SQL 파서 및 전처리기
- 옵티마이저

3가지가 중심을 이룬다. 또한 성능 향상을 위해 MyISAM의 키 캐시, InnoDB의 버퍼 풀, 보조 저장소 기능이 포함되어있다.



### 스토리지 엔진

MySQL엔진은 요청된 SQL 문장을 분석하거나 최적화하고

실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분은 스토리지 엔진이 전담한다. 



MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러개를 사용할 수 있다. 



### 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터 쓰거나 읽어야 할 때는 스토리지 엔진에게 요청을 "핸들러 요청"이라고 한다. 

핸들러 API를 이용해 MySQL 엔진과 데이터를 주고 받는다. 

~~~sql
show global status like 'Handler%'
~~~

: show status - MySQL 데이타베이스의 현재 상황을 확인한다. 

global : 시스템 전역 변수값 반대로 SESSION이 존재하고 현재 연결에 유요한 값을 표시한다.

![MySQL](../img/show.png)

- referencs : https://dev.mysql.com/doc/refman/8.0/en/server-status-variables.html

 - Handler_read_first : Index의 첫번째 Node Access, FULL_INDEX_SCAN
 - Handler_read_key : 특정값으로 Tree Search를 통해 index Node를 선택하는 경우, INDEX_SEEK
 - Handler_read_next : 인덱스의 leaf노드들의 링크를 Range스캔할 경우
 - Handler_read_prev : 위와 반대로 역순 Range스캔
 - Handler_read_random : Sorting같은 Buffer에 저장된 row에 대한 Access
 - Handler_read_random_next : 데이터Block나 Temp Table에서 순차적으로 row를 읽는 경우,FULL_TABLE_SCAN

: 추후 index에서... 



## 1.2 스레딩 

프로세스 기반이 아닌, 스레드 기반으로 

포그라운드 / 백그라운드 두가지로 구분된다.

SQL 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만, 읽기 작업은 절대로 지연될 수 없다.

일반적으로 DBMS는 쓰기 작업은 버퍼링을 통한 일괄처리 기능이 탐재되어 있다. (InnoDB)

MyISAM의 경우는 사용자가 스레드가 직접 쓰기 작업까지 처리한다.

이러한 이유로 InnoDB에서는 insert / update / delete 디스크에 저장될떄가지 기다리지 않아도 되지만 

MyISAM의 경우 버퍼링 기능을 사용할 수 없다.

### 포그라운드(클라이언트) = 사용자 스레드

MySQL 서버에 접속된 클라이언트의 수만큼 존재하며 주로 클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 것이 임무다.

클라이언트가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드풀로 돌아간다.

만약 thread_cache_size보다 많으면 스레드풀로 돌아가지 않는다.

MySQL의 데이터 버퍼나 캐시로부터 데이터를 가져오고, 버퍼나 캐시에 없는 경우 직접 인덱스 파일로부터 데이터를 읽어와서 처리한다.

MyISAM 테이블 디스크 쓰기 작업까지 포그라운드 스레드가 처리하지만, InnoDB의 경우 디스크 기은 백그라운드 스레드가 처리한다.

### 백그라운드

마이아이삼의 경우에는 해당 사항이 별로 없다.

이노디비의 경우 인서트 버퍼, 로그 기록, 데이터 버퍼에서 디스크로 기록, 디스크에서 버퍼로 읽어들이는, 데드락 모니터링 등 여러가지 업무를 처리한다.


- 로그 스레드 : 로그를 디스크로 기록하는 작업
- 쓰기 스레드 : 버퍼의 데이터를 디스크로 내려 쓰는 작업, 해당 스레드 개수를 지정할 수 있다. (innodb_write_io_threads)


## 1.3 메모리 

크게 글로벌 / 로컬 두가지 영역으로 구분된다.

- 글로벌 : MySQL 서버가 시작되면서 운영체제로부터 할당된다 .

MySQL 수많은 스레드가 공유하는 자원이 글로벌, 아니면 로컬


- 로컬 : 세션 메모리 영역이라고 표현하며 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다. 

커넥션이 열려 있는 동안 남아있는 공간 (버퍼)과 쿼리 실행하는 순간에만 할당했다가 사라지는 공간(소트버퍼, 조인버퍼)도 있다.


## 1.4 플러그인 스토리지 엔진 모델 

MySQL의 독특한 구조?로 플러그인 모델이 있다. 

전문 검색 엔진을 위한 파서(인덱싱할 키워드를 분리)도 플러그인 형태로 개발해서 사용할 수 있다. 

### 쿼리 실행 과정 

- SQL 파서 -> SQL 옵티마이저 -> SQL 실행기 -> 데이터 읽기/ 쓰기 -> 디스크 
(MySQL 엔진의 처리 영역) ------------------/(스토리지 엔진의 처리 영역) / 디스크 

데이터 읽기 / 쓰기 작업은 거의 대부분 1건의 레코드 단위로 처리된다. 

핸들러라는 표현을 자주 볼 수 있을텐데, 이는 소스코드로부터 넘어온 표현이다. 

Group By , Order By 와 같은 복잡한? 쿼리는 스토리지 엔진 영역이 아니라 MySQL 처리 영역인 쿼리 실행기에서 처리된다. 


스토리지 엔진에 따라서 데이터 읽기 / 쓰기 많이 달라진다는 소리이다. 


### show engines 

~~~sql
show engines 
~~~
- YES : 서버에 포함돼 있고, 사용 가능 
- DEFAULT : 필수 엔진, 없으면 MySQL이 시작될 수 없음 
- NO : 포함되지 않음 
- DISABLED : 포함됐지만, 파라미터에 의해 비활성화

### show plugins 

엔진 뿐만 아니라, 플러그인 살펴 볼 수 있다.
~~~sql
show plugins 
~~~

## 1.5 쿼리 실행 구조 

0. 쿼리 요청 
1. 쿼리 컴파일러 
   - 2.1 쿼리 파서 
   - 2.2 전처리기 
   - 2.3 옵티마이저 (쿼리 변환, 비용 최적화, 실행계획 개선)
2. 쿼리 실행기 
3. 스토리지 엔진 
4. 하드웨어 
5. 스토리지 엔진
6. 쿼리실행기
7. 응답 
  
### 파서 

쿼리 문장을 토큰으로 분리하는 작업으로 트리 형태의 구조로 만들어 내는 작업이다. 문법 요류가 이 과정에서 발견된다.

토큰 : MySQL이 인식할수 있는 최소 단위
    
### 전처리기 

파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다. 

테이블 이름, 컬럼 이름, 권한과 같은 체크이다. 

### 옵티마이저 

최적화 쿼리를 담당한다. 

### 실행 엔진 

옵티마이저가 두뇌라면, 실행헨진은 손과 발로 비유 할 수 있다. 

실행엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.

= 파이프라인?
    
### 핸들러 (스토리지 엔진)
MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.

핸들러는 결국 스토리지 엔진을 의미하며, MyISAM 테이블을 조작하는 경우에는 핸들러가 MyISAM 스토리지 엔진이 되고, InnoDB 테이블을 조작하는 경우

핸들러가 InnoDB 스토리지 엔진이 된다. 

## 1.6 복제 

복제는 리플리케이션이라고 하는데, 복제는 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술이다. 

마스터-슬레이브 구조를 사용한다.

### 마스터 

MySQL의 바이너리 로그가 활성화되면 어떤 MySQL 서버든 마스터가 될 수 있다.

애플리케이션 입장에서 본다면 마스터 장비는 주로 데이터가 생성 및 변경 삭제되는 주체라고 볼 수 있다.

데이터 구조 변경 쿼리는 바이너리 로그에 기록하고, 슬레이브 서버에서 바이너리 로그를 읽는다.

Binlog dump 스레드가 해당 업무를 담당하는 스레드이다. 

### 슬레이브 

슬레이브 서버는 릴레이 로그를 가지고 있다. 

마스터로부터 변경 내역을 요청하고 받아온 변경 내역을 릴레이 로그에 기록한다. 

릴레이 로그에 기록된 변경 내역을 재실행하여 마스터와 동일한 상태로 유지한다. 


- 슬레이브는 하나의 마스터만 설정 가능

- 마스터/슬레이브 동기화를 위해 슬레이브는 읽기 전용으로 설정

- 슬레이브 서버는 마스터와 동일한 사양이 적합 
: 수많은 데이터 변경 쿼리가, 슬레이브에서는 하나의 스레드로 모두 처리돼야 한다. 
변경이 잦은 서버일수록 슬레이브 서버의 사양이 더 좋아야 한다. 대게 변경은 조회의 1/10이라 동일한 사양으로..

- 복제가 불필요할 경우 바이너리 로그 중지 
: 바이너리 로그를 생성하기 위해 많은 자원을 소모한다.

로그를 안정적으로 기혹하기 위해 Gap lock, 트랜잭션 커밋마다 쿼리 문장을 바이너리 로그에 기록해야 한다.

AutoCommit이 활성화되면 더욱 심각한 부하로 나타나는데, MyISAM의 경우 AutoCommit라 더욱 많은 자원을 소모한다.

- 바이너리 로그와 트랜잭션 격리 수준 

: 바이너리 기록 방식에 따라서 statement 포맷 방식과 row 포맷 방식이 있다. 

statement의 경우 마스터에서 실행되는 쿼리 문장을 기록하는 방식이며, row 포맷은 마스터에서 실행된 쿼리에 의해 변경된 레코드의 값을 기록하는 방식이다.

statement는 아무리 데이터를 많이 변경하더라도 sql 문장으로 전달히개 때문에 트래픽이 적지만, 정상 복제를 위해서 repeatable-read 사용한다.

반면 row 기반은 트래픽이 많이 발생히지만 read-commit 사용 가능하다.


## 1.7 쿼리 캐시

쿼리 캐시는 단어의 의미와는 달리 SQL 문장을 캐시하는 것이 아니라 **쿼리의 결과**를 메모리에 캐시해 두는 기능이다. 

### 처리 절차 
1. 요청된 쿼리 문장이 캐시에 존재하는가?
    - 공백이나 탭과 같은 문자까지 모두 포함되며, 대소문자까지 완전히 동일해야 같은 쿼리로 인식된다.
2. 결과를 볼 수 있는 권한이 있는가??
3. 트랜잭션 내에서 실행된 쿼리인 경우, 그 결과가 가시 범위 내의 트랜잭션에서 만들어진 결과인가?? (InnoDB)
    - 트랜잭션은 순차적으로 증가하는 6바이트 숫자값으로 ID 를 갖는다. 자신의 ID보다 ID 값이 큰 크랜잭션에서 변경한 작업내역이나 쿼리 결과는 참조할 수 없다.
4. 쿼리에 사용된 기능이 캐시돼도 동일한 결과를 보장할 수 있는가??
    - SYSDATE, RAND 등과 같은 호출 시점에 달라지는 값
    - 프리페어 스테이트먼트의 경우 변수가 결과가 영향을 주는가?
5. 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?
6. 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않을까?
7. 그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 사용됐는가?
    - 임시 테이블, 사용자 변수, SELECT Lock 등의 요소들
    

### 쿼리 캐시 히트율 

~~~sql
show global status
~~~    

캐시 히트율 : Ocache_hits / (Ocache_hits  + Com_select) * 100

Ocache_hits : 캐시 처리로 처리된 수
Com_select : 캐시에서 쿼리를 찾지못해 쿼리를 실행한 수

## 1.8 InnoDB 엔진의 특성 

### 프라이머리 키에 의한 클러스터링 
모든 테이블은 프라이머리키 를 기준으로 클러스터링 되어 저장된다. 즉 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이며 
나중에..자세히

### 잠금 없는 읽기 

MVCC(Multi Version Concurrency Control) 기술을 이용해 락을 걸지 않고 읽기 작업을 수행한다. 이것도 나중에..

### 외래 키 지원

마이아이삼에서는 사용 불가능하다.  하지만 이로인해 데드락 발생할 때가 많다. 

### 자동 데드락 감지

데드락 체크 방식으로 변경사항이 적은 트랜잭션을 롤백시킨다. 

### 자동화 복구 

손실이나, 장애가 발생했을 때, 완료하지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지에 대한 복구작업을 한다. 추후에..

### 오라클 아키텍처

MVCC / Undo 오라클과 비슷하다.

## 1.9 InnoDb 버퍼 풀

가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다. 

쓰기 작업을 지연시켜서 일괄 작업으로 처리할 수 있게 해주는 버퍼역할도 한다.


마이아이삼 키 캐시가 인덱스의 캐시만을 주로 처리하는데 비해 InnoDB 버퍼 풀은 데이터와 인덱스 모두 캐시하고 

쓰기 버퍼링의 역할까지 모두 처리한다. 

디스크에 기록되지 않은 데이터를 가지고 있다. (더티 페이지)


주기적 or 특정 조건에 따라 체크 포인트 이벤트가 발생하고 이때 Write 스레드가 필요한 만큼의 페이지만 디스크에 기록한다. 

## 1.10 언두 로그 

업데이트, 델리트와 같이 데이터가 변경될때, 변경하기 전에 보관하는 곳이다. 

(트랜잭션을 커밋하지 않더라도 내용을 undo에 기록한다. )

롤백용도와 격리수준 & 동시성을 제공하는데 사용된다. 

## 1.11 인서트 버퍼 


인서트, 업데이트는 데이터 파일을 변경하는 작업 뿐만 아니라, 해당 테이블에 포함된 인덱스를 업데이트 하는 작업도 필요하다.

인덱스 작업은 상당히 많은 자원을 소모하므로, 변경해야할 인ㄷ게스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행한다.

그렇지 않고 디스크로부터 읽어와서 업데이트해야 한다면 즉시 실행하지 않고 임시 공간에 저장해두고 바로 사용자에게 결과를 반환한다.

이떄 사용하는 메모리 공간을 인서트 버퍼라고 한다.


## 1.12 리두 로그 및 로그 버퍼 

앞서 버퍼 풀과 같은 장치로 성능 향상을 하지만, 이 장치만으로는 ACID를 보장 할 수 없다.

변경된 내용을 순차적으로 디스크에 기록하는 로그 파일을 가지고 있다. 

커밋한 트랜잭션의 수정은 어떤 경우에도 유지(durability)되어야 한다. 이는 커밋한 트랜잭션의 수정을 재반영하는 작업을 REDO라고 한다. 


### Undo / Redo

REDO 는 UNDO를 포함 합니다.
REDO 는 시스템 장애시 복구를 위해 사용 합니다.
복구시에 UNDO 데이터도 같이 복구하구요. Commit 되지 않은 데이터를 Rollback 하게 됩니다.
UNDO 는 Rollback 시에도 사용 되지만 Read Consistency(읽기 일관성) 을 위해서 도 사용 됩니다.
REDO 는 모든 변경사항(UNDO 포함)을 기록 합니다.
복구는 UNDO 를 통해서 복구를 하게 됩니다. 즉, ROLLBACK을 한다는 말이죠.
시스템 장애가 발생하게 되면 UNDO 데이터도 모두 날아가게 되겠죠.
결국 시스템 장애시 REDO 데이터를 이용해서 마지막 CHECK POINT 부터 장애까지의 DB BUFFER CACHE 를 복구하게 됩니다.
이게 완료가 되면 UNDO DATA 를 이용하여 COMMIT 되지 않은 데이터를 모두 ROLLBACK 함으로써 복구를 완료하게 됩니다.
결국 REDO 가 UNDO 를 복구하고 최종적으로 UNDO가 복구를 하게 됩니다.
UNDO(안한것 처럼)는 되돌리는 것 이라고 보시면 될거에요.
어떤 세션에서 DML을 발생시키면 commit이나 rollback을 날리기 전까지 이전 정보를 저장하기 위해서
UNDO 블럭에 해당 정보를 기록하죠.. 해당 세션이 트렌젝션 중에 비정상적으로 종료가 되었다면,
안한것 처럼(UNDO) 다시 원복해야 되니까요.
REDO(다시 함)는 위에 설명에도 있듯이 인스턴스 실패시(DB가 내려감) 데이터 파일에 쓰여지지 않은 커밋된 데이터를 복구한다고 되어 있습니다.
좀 더 설명을 해드리자면 커밋을 날릴 경우 LGWR가 로그 파일에 변경된 정보를 기록하게 되고
그 다음에 DBWR이 버퍼캐쉬에 있는 변경 사항에 대해서 데이터 파일에 내려 쓰게 됩니다.
이는 복구 정보가 더 중요해서 그런 것이라고 이해하시면 됩니다(복구 정보가 있으면 재적용이나 되돌릴 수 있으므로).
DB가 비정상적으로 내려가면, 데이터 파일에 쓰여지지 않은 정보들이 리두로그에 기록되어 있으므로
리두로그에서 정보를 가져와 다시 적용(REDO)하는 것입니다.

- REDO 복구 단계로 복구를 시작해야 하는 시점부터 장애 발생 직전 시점까지 REDO가 필요한 모든 로그를 REDO 복구를 하는 단계이다. 

모든 트랜잭션에 대해서 REDO 복구만 한다는 점이 중요한데, 이러한 REDO 복구가 완료된 시점의 데이터베이스 상태는 장애 발생 시점의 상태와 같게 된다.

- UNDO 복구 단계로 로그를 최신 시점부터 다시 역방향으로 탐색하면서 UNDO 복구가 필요한 로그들에 대해서 UNDO 복구를 수행한다. 

여기서 수행하는 UNDO는 결국 위에서 설명한 트랜잭션 철회 시에 수행하는 UNDO와 같은 방식으로,  

데이터베이스 상태를 장애 시점까지 복원해두고 UNDO 복구를 여러 트랜잭션의 철회로 간단하게 해결할 수 있다.


## 1.13 MVCC

잠금을 사용하지 않고 일관된 읽기를 제공하는 기능으로 undo를 통해 구현한다. 

쿼리의 커밋 여부와 상관없이 버퍼풀은 업데이트된다. (디스크 데이터 파일도 동일하다고 볼 수 있다. Write 스레드에 의해..)

격리수준에 따라 다르겠지만, READ_UNCOMMITTED 라면 버퍼풀 or 디스크에서 읽어가고 

READ_COMMITTED 이상이면 언두 영역에서 읽어온다. 

## 1.14 non-locking consistent read

serializable 아니 경우 select 작업에 대해서 잠금 없이 바로 실행한다.

다른 변경 트랜잭션이 방해하지않고, 변경되기 전의 데이터를 읽기 위해서 언두를 사용한다.

## 1.15 마이아이삼 vs 이노디비
그냥 이노디비 쓰자...

그나마 장점인 전문 검색 기능도... 스핑크스?? 트리튼?? 서드 파티를 쓰는 것이 낫다고 한다.

## 1.16 이노디비와 메모리 스토리지

메모리 스토리지 엔진은 데이터와 인덱스를 모두 메모리에 저장하기 떄문에 매우 빠르다. 

하지만 레코드 수준이 아니라 테이블 수준의 잠금을 이용한다. 그렇기에 동시적인 트래픽이 몰리면

낮은 성능을 보여준다.

 
## 1.17 MyISAM 키 캐시

InnoDB 버퍼풀과 비슷한 역할이다. 인덱스만 대상인데, 또한 인덱스의 디스크 쓰기 작업에 대한 부분적으로 버퍼링 역할을 한다. 

## 1.18 운영체제의 캐시 및 버퍼 
인덱스는 키 캐시를 통해 디스크를 검색하지 않고도 충분히 빠른 검색이 가능하다. 
하지만 데이터는 디스크로부터 I/O 해결해줄 만한 어떠한 캐시나 버퍼링 기능이 없다. 


그래서 운영체제의 캐시 및 버퍼를 사용한다. (InnoDB의 버퍼에는 ... 엄청 구리지만 없는것보단.. 나으니깐)

## 1.19 MEMORY 스토리지 

데이터를 메모리에 저장한다. 

테이블의 최대 크기가 적다. 고정 길이 컬럼 지원, BLOB / LOB 사용 불가능 / 해시 인덱스 사용 

레디스 하위호환...?? 

추후에 배울 임시 테이블용도로 사용한다는...


## 1.20 NDB 클러스터 스토리지 엔진 

Network Database, 네트워크를 통해 데이터 분산을 지원하는 스토리지 엔진이다. 

데이터 분산이나 그로 인한 성능 향상보다는 가용성에 집중된 스토리지 엔진이다. 

관리 노드, 데이터 노드, SQL 노드(or API노드)로 구성된다. 

기본적으로 메모리기반이다. (디스크도 지원이 가능하다.)

빠른 동기화를 위해 메모리를 사용한다. Redis가 있는데... 굳이...

### SPoF (Single Point of Failure)

시스템 구성 요소 중에서, 동작하지 않으면 전체 시스템이 중단되는 요소를 말한다.

### NoSQL
 
NoSQL에서는 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있습니다. 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있습니다.

또한 테이블 간의 관계를 정의하지 않기에, 데이터 분산이 용이하며 성능 향상을 위한 Saclue-up 뿐만이 아닌 Scale-out 또한 가능합니다.

- 스키마(schema) : 필드는 데이터 유형뿐만 아니라 제약사항도 지정할 수 있는데 이러한 제약사항을 스키마라고 부른다
- schema-less : key만 똑같다면 각각의 row들이 다른 컬럼을 갖는 구조 


### 관리노드 

정상상태에서 사용되는 일이 없고, 장애 상황, 처음 시작, 노드 추가,삭제 등에 사용된다. 

### 데이터노드 

데이터 조작 요청을 모두 처리하는 노드이다.

### SQL 노드 (SQL , API)
MySQL 서버를 통해 SQL노드 방식 or 자바 API 사용하는 방식 2가지가 있다. 


## 1.21 TokuDB

elasticSearch가 있는데,,, 굳이... 그냥 skip

## 1.22 전문 검색엔진 

MySQL은 % 연산자를 사용하여 LIKE 패턴 연산을 지원할 뿐만 아니라, 
단어 또는 구문에 대한 검색을 지원하며 이를  풀 텍스트(FULLTEXT) 검색이라고 부른다. MySQL은 3가지 종류의 FULLTEXT 검색 방식을 지원한다.

- 자연어 검색(natural search)
검색 문자열을 단어 단위로 분리한 후, 해당 단어 중 하나라도 포함되는 행을 찾는다.
- 불린 모드 검색(boolean mode search)
검색 문자열을 단어 단위로 분리한 후, 해당 단어가 포함되는 행을 찾는 규칙을 추가적으로 적용하여 해당 규칙에 매칭되는 행을 찾는다.
- 쿼리 확장 검색(query extension search)
2단계에 걸쳐서 검색을 수행한다. 첫 단계에서는 자연어 검색을 수행한 후, 첫 번째 검색의 결과에 매칭된 행을 기반으로 검색 문자열을 재구성하여 두 번째 검색을 수행한다. 
이는 1단계 검색에서 사용한 단어와 연관성이 있는 단어가 1단계 검색에 매칭된 결과에 나타난다는 가정을 전제로 한다.

추후 자세히 다르겠죠???

### 트리톤

일본이 만들었으니 스킵


## 1.23 MySQL 로그파일 

MySQL의 상태나 부하를 일으키는 원인을 찾아서 해결할 수 있다.  

log_error 옵션으로 에러, 경고 메시자가 출력된다. default로 *.err에 저장된다. 

- MySQL 시작하는 과정에서 에러 : 변수의 이름, 값 제대로 설절되었는지. (run 에러라고 보면 될듯,,, spirng run에러는 컴파일 에러일까 빌드 에러일까 런타임 에러일까?)

- 비정상적으로 종료된 경우 나타나는 InnoDB 트랜잭션 복구 메시지

- 쿼리 도중 발생하는 에러 메시지 

- 클라이언트 애플리케이션에서 정상적으로 접속 종료를 하지 못하고 프로그램이 종료된 경우 

- InnoDB 테이블의 모니터링, 락, 엔진 상태 조회 명령에 대한 결과가 쌓이게 된다. 

- MySQL 종료 메시지 

### General Log

MySQL 서버에서 실행되는 쿼리로 어떤 것들이 있는지 전체 목록을 뽑아 검토해볼 때, 쿼리 로그를 활성화해서 쿼리를 쿼리 로그 파일로 기록하게 한 다음, 그 파일을 검토하면 된다.

### Slow log query

MySQL 서버의 쿼리 튜닝은 크게 서비스가 적용되기 전에 전체적으로 튜닝하는 경우와 서비스 운영중에 MySQL 서버의 전체적인 성능 저하를 검사하거나 또는 정기적인

점검을 위한 튜닝으로 나눌 수 있다. 전체적으로 튜닝하는 경우는 크게 상관없지만, 운영 중인 서비스 원인을 찾아 고치려면 slow log를 봐야한다.

 
- 설정 옵션들

~~~
log-output = FILE 또는 TABLE
slow-query-log = 1
long_query_time = 1
slow_query_log_file=/var/log/log/mysql-slow.log
~~~

MySQL의 잠금처리는 MySQL 엔진 레벨과 스토리지 엔진 레벨의 두 가지 레이어로 처리되는데

MyISAM / MEMORY의 경우는 별도의 스토리지 엔진은 없다. 

~~~
# Time: 110202 12:13:14
# User@Host : root[root] @ localhost []
# Query_time: 15.407663 Lock_time: 0.0000197 Rows_sent: 0 Rows_examined: 5
update tab set fd=100 where fd=10;
~~~

- 슬로우 로그 해석하기
    - Time : 쿼리가 종료된 시점
    - Query_time : 쿼리가 실행되는데 걸린 전체시간
    - Lock_time : MySQL 엔진 레벨에서 관장하는 테이블 잠금에 대한 대기 시간
    - Rows_examined : 쿼리가 처리되기 위해 접근한 record 수
    - Rows_sent : 클라이언트에 보낸 record 수

MyISAM, MEMORY 스토리지 엔진에서는 테이블 단위의 잠금을 사용하지만 

InnoDB 또한 테이블 대한 SELECT Lock_time이 0이 아닌 경우가 발생하는데, 이부분은 InnoDB 스토리지 엔진이 아닌 MySQL서버 엔진 레벨에서

설정한 테이블 잠금 때문일 가능성이 높다. (Lock_time 튜닝은 도움이 되지 않는다.)

명시적으로 얻는 LOCK TABLES tb_trest 명령은 기록되지 않는다.

mysqlslowdump 프로그램이 분석에 좋다.

### 바이너리 로그, 릴레이 로그

바이너리 : 마스터에서 생성되는 로그 

릴레이 : 슬레이브에서 생성되는 로그 

둘의 포맷은 동일하다.  


# 1주차 4. 트랜잭션과 잠금 

트랜잭션 : 하나의 기능을 수행하기 위해 복수의 쿼리를 하나로 묶어서 처리하는 작업의 단위로 데이터의 정합성을 보장하기 위한 기능

논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 돌리는 기능 

잠금 : 동시성을 제어하기 위한 기능 


## 2.1 주의사항 

### 트랜잭션 시간 

- 트랜잭션을 오래 물고 있으면 어떤 점이 좋지 않을까??? (면접 질문)

: 일단 커넥션을 오래 물고 있으면 사용 가능한 여유 커넥션의 개수가 줄어든다. 트랜잭션 격리 수준에 따른 데이터의 처리 및 잠금 오버헤드가 발생할 것 이다.

또한 데드락 발생 가능성을 높인다.

다시한번 데드락 간단히 설명하면, REPEATABLE-READ에서는 현재 Select 버전을 보장하기 위해 Snapshot을 이용하는데(Undo) 
Select 작업이 종료될 때까지 해당 데이터 변경 작업(Update, Delete)이 불가합니다. 그런데 이때 변경작업을 시도했을때 대기 현상 또는 Dead Lock 오류 발생합니다

- 전체 List 1000만건을 한번에 업데이트 하는 경우와 조금씩 짤라서 업데이트 하는 경우 비교해볼까??

## 2.2 잠금 

### 글로벌 락
FLUSH TABLES WITH RAED LOCK 명령으로만 획득할 수 있으며, 
한 세션에서 글로벌 락을 획득하면 MySQL 서버 전체에 락이 걸린다. 다른 세션은 SELECT을 제외한 대부분의 DDL 문장이나 DML 문장 실행을 대기하게 된다.

### 테이블 락
- 개별 테이블 단위로 설정되는 잠금
- 명시적 잠금 : LOCK TABLES table_name [READ | WRITE], 해제 : UNLOCK TABLES
- 온라인 작업에 상당한 영향을 미치기 때문에 특별한 상황이 아니면 애플리케이션에서 거의 사용할 필요가 없다.
- 묵시적 잠금은 MyISAM 혹은 MEMORY 테이블에 데이터를 변경하는 쿼리가 실행되면 발생한다.
- InnoDB는 레코드 기반의 잠금을 제공하기 때문에 DDL이 발생하는 경우에만 테이블 락이 걸리게 된다.


### 유저 락
- GET_LOCK() 함수를 이용해 임의로 잠금을 설정할 수 있는데, DB 객체에 대해 잠금을 거는 것이 아니라, 사용자가 지정한 문자열에 대해 잠금을 걸고 해제하는 방식이다
- 한꺼번에 많은 레코드를 변경하는 쿼리의 경우 데드락의 원인이 될 수 있기 때문에 이럴때 유저 락을 활용할 수 있다.

### 네임 락
데이터베이스 객체(대표적으로 테이블 or 뷰)의 이름을 변경하는 경우 획득하는 잠금이다. 
명시적으로 획득하거나 해제할 수 없고 RENAME TABLE 등의 명령어를 사용했을때 잠금되었다 해제된다.


## 2.3 MyISAM 스토리지 엔진의 잠금

MyISAM 쓸 경우가 거의 없으니....  자세히 보진 말자. 

자체적으로 없기 때문에 MySQL 테이블 단위의 잠금 처리를 사용한다.

### 잠금 획득 

- 읽기 잠금 : 테이블에 쓰기 잠금이 걸려있지 않으면 읽기 잠금을 획득하고 읽기 작업을 수행한다.

- 쓰기 잠금 : 테이블에 아무런 잠금이 걸려 있지 않아야만 쓰기 잠금을 흭득할 수 있다.

~~~sql
show status like 'Table%'
~~~

- Table_locks_immediate : 다른 잠금이 풀리기를 기다리지 않고 바로 잠금을 흭득한 횟수
- Table_locks_waited,0 : 다른 잠금이 이미 해당 테이블을 사용하고 있어서 기다려야 했던 횟수

잠금 쿼리 비율 = Table_locks_waited / Table_locks_immediate + Table_locks_waited

## 2.4 InnoDB 스토리지 엔진의 잠금

MySQL 잠금과 별개로 스토리지 엔진을 사용하며 테이블 단위가 아닌 레코드 단위 잠금 방식이다. 

information_schema 데이터 베이스에 INNODB_TRX, INNODB_LOCKS.. 과 정보를 볼 수 있다. 

### 잠금 방식 
- 비관적 잠금 : "내가 변경하고자 하는 레코드를 다른 트랜잭션에서도 변경할 수 있다"라는 비관적인 전제를 가지고 레코드를 변경하기 전에 아무도 못들어오게 잠궈두는 방식 (InnoDB가 사용하는 방식)

- 낙관적 잠금 : 트랜잭션이 같은 레코드를 변경할 가능성은 희박하다고 가정하고, 일단 잠금 없이 변경한 후에 마지막에 충돌이 있었는지 확인하여 ROLLBACK처럼 처리하는 방법


### 잠금 종류 
- 레코드 락 : 레코드만을 잠그는 것. 중요한 차이는 InnoDB의 경우 인덱스의 레코드를 잠그게 된다. 

보조 인덱스를 이용한 변경 작업은 넥스트 키 락이나 갭 락을 사용하거나 PK 혹은 유니크 인덱스에 의한 변경작업은 레코드 락을 건다.

- 갭 락 : 레코드 자체 뿐아니라 바로 인접한 레코드 사이의 간격만을 잠그는 것. 

갭 락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것이다. 이것은 실존하는 것이 아니라 개념일뿐이며, 넥스트 키 락의 일부로 사용된다.

- 넥스트 키 락 : 레코드 락과 갭 락을 합쳐 놓은 형태이다. STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE_READ 격리 수준을 사용해야 한다. 

InnoDB의 갭 락이나 넥스트 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.

그런데 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.

row단위로 바꿀 경우 락을 줄일수 있는데, 아직 안정성이 부족하다는...???

- 자동 증가 락 : 자동 증가하는 숫자 값을 추출하기(Auto Increment) 위한 락으로 명시적으로 획득/해제할 수 없다.


## 2.5 인덱스와 잠금 

InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다. 즉 변경해야할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다.

~~~sql
UPDATE SET updated_date = NOW() where first_name = 'tire' and last_name = 'ho'
~~~

first_name은 index가 있고, last_name 인덱스가 없는 경우 

first_name이 'tire'인 레코드가 전부 잠긴다. 

만약 first_name 인덱스도 없다면 풀스캔 잠금이 발생된다. 인덱스 설계까 중요하다.

## 2.6 트랜잭션 격리 수준과 잠금 

InnoDB의 넥스트 키락의 주 원인은 복제를 위한 바이너리 로그 때문이다. 

로그 기반으로 변경하면 줄일 수 있다.

격리 수준을 READ-COMMITTED 으로 변경 or 레코드 기반의 바이너리 사용 등으로 락을 줄일 수 있다는..

### 레코드 잠금 확인 

테이블 보다 복잡하다. 

~~~sql
SHOW PROCESSLIST;
~~~
현재 사용중인 쿼리를 통해 대략적으로 잠금을 확인 할 수 있다. 

stats가 updating으로 표시, 2~3초 이상 된다면 잠금인건가?? 유추한다.

~~~sql
SELECT * FROM information_schema.INNODB_TRX

SELECT
  r.trx_id waiting_trx_id,
  r.trx_mysql_thread_id waiting_thread,
  b.trx_id blocking_trx_id,
  b.trx_mysql_thread_id blocking_thread,
  b.trx_query blocking_query
FROM information_schema.innodb_lock_waits w
  INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
  INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;
~~~

: 테이블 접근이.. 안되는 것 같은..

innodb_lock_waits을 통해 잠금, 대기 확인 

INNODB_TRX 트랜잭션 확인 

waiting.. 칼럼은 잠금을 기다리는 트랜잭션이나 프로세스이며, blocking... 칼럼은 잠금을 해제하지 않아 다른 트랜잭션을 막고 있는 트랜잭션이나 프로세스이다.


##  2.6 MySQL 격리 수준

트랜잭션 격리 수준 : 동시에 여러 트랜잭션이 처리 될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼수 있도록 허용할지 말지 결정하는 것

즉 복수의 트랜잭션이 동시에 실행해도 각각의 처리가 모순없이 실행되는 것을 보증한다.



### READ UNCOMMITED
이름 그대로 commit 되지 않은 레코드를 읽을 수 있게 하는 것이다.

때문에 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데 다른 트랜잭션에서 볼 수 있는 Dirty Read 현상이 나타난다.

정합성에 문제가 많은 격리수준이다.

### READ COMMITED
commit 된 레코드만 읽을 수 있게 하는 것이다. 하지만 NON-REPEATABLEREAD 문제가 발생할 수 있다. 이 문제는 다음과 같다.

A가 트랜잭션을 시작해 SELECT 구문을 사용한다 → 나온 결과가 1개
B가 트랜잭션을 시작해 INSERT 구문을 사용한다
B가 트랜잭션을 commit 한다
A가 트랜잭션을 끝내기 전에 SELECT 구문을 한 번 더 사용한다 → 오잉 2개? 아까랑 바꼈다
이는 금전적인 처리와 연결되면 더 문제가 될 수 있다. 예를 들어, 다른 트랜잭션에서 입금과 출금 처리가 계속 진행되고 있을 때 다른 트랜잭션에서 오늘 입금된 금액의 총합을 조회한다고 가정해보자. 그런데 'REPEATABLE READ'가 보장되지 않기 때문에 총합을 계산하는 SELECT 쿼리는 실행될 때마다 다른 결과를 가져올 것이다.

### REPEATABLE READ
InnoDB의 기본 방식으로 Undo 로그를 사용해 현 시점의 과거 데이터를 읽어올 수 있도록 한다 (3장 InnoDB MVCC 참고)

REPEATABLE READ 격리 수준에서는 MVCC를 보장하기 위해 실행중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 undo 영역의 데이터는 삭제할 수가 없다. 더 정확하게는 특정 트랜잭션 번호의 구간 내에서 백업된 언두 데이터가 보존돼야 하는 것이다.

### SERIALIZABLE
읽기 작업도 공유 잠금(읽기 잠금)을 획득해야 하며, 동시에 다른 트랜잭션은 동일한 레코드를 변경하지 못한다.


# 실습 

### Handler 조회 
핸들러 API를 이용해 MySQL 엔진

### engines 조회 
엔진 조회해보자.

### 캐시 히트율 조회 

캐시 히트율을 알아보자.

### 유저 락
1. hello 문자열의 user_lock을 3초 흭득해보자.
2. hello 문자열에 대한 잠금이 설정돼 있는지 확인한다.
3. hello 문자열 잠금 반납하자.









## References

- https://d2.naver.com/helloworld/407507
- https://pat98.tistory.com/565








    
    



    
















